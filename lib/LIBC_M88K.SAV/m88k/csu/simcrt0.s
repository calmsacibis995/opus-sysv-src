;	@(#)crt0.s	6.1 
;
;	M78000 _start(3) Routine
;
;	(C) Copyright 1987 by Motorola Inc.
;
;	Written by: Bob Greiner
;
; _start - interface between Unix process launch and C programs
;
; Input:	sp - stack pointer register, with formatted data
;		arg0 - initial stack limit
;
;	The format of the data on the stack is:
;
;	arg0 -->initial stack limit
;
;	sp   -->argc
;	argv -->pointer to the text for the first argv entry
;		pointer to the text for the second argv entry
;		...
;		pointer to the text for the last argv entry
;		NIL
;	env  -->pointer to the text for the first env entry
;		pointer to the text for the second env entry
;		...
;		pointer to the text for the last env entry
;		NIL
;		text for the first argv entry
;		text for the second argv entry
;		...
;		text for the last argv entry
;		text for the first env entry
;		text for the second env entry
;		...
;		text for the last env entry
;
;	or
;
;	arg0 -->initial stack limit
;
;	sp   -->argc
;	argv -->pointer to the text for the first argv entry
;		pointer to the text for the second argv entry
;		...
;		pointer to the text for the last argv entry
;	env  -->NIL
;		text for the first argv entry
;		text for the second argv entry
;		...
;		text for the last argv entry
;
;	These two patterns are differentiated by the pointer
;	to the text for the first argv entry pointing immediately
;	after the first NIL.
;
;	Note the implication that argc >= 1, and that argv[0]!=NIL.
;	Thus, the minimum startup data pattern is
;
;	arg0 -->initial stack limit
;
;	sp   -->word 1
;	argv -->word argv.0
;	env  -->word 0
;	argv.0->byte 0
;
; Output:	NEVER RETURNS
;
_m4_define_(`argc', r2)_m4_dnl_
_m4_define_(`argv', r3)_m4_dnl_
_m4_define_(`env', r4)_m4_dnl_
_m4_define_(`temp', r5)_m4_dnl_
;
_m4_define_(`m_argc', `sp,0')_m4_dnl_
_m4_define_(`m_argv', `sp,4')_m4_dnl_
_m4_define_(`m_env', `sp,8')_m4_dnl_
;
	text
	global	__start
	global	splimit%
	global	_environ
	global	_initfpu
	global	_exit
	global	_main
;
__start:
	or.u	r26,r0,0		; special hole for linker synthesis
	or	r26,r26,0		; special hole for linker synthesis
	or.u	r27,r0,0		; special hole for linker synthesis
	or	r27,r27,0		; special hole for linker synthesis
	or.u	r28,r0,0		; special hole for linker synthesis
	or	r28,r28,0		; special hole for linker synthesis
	or.u	r29,r0,0		; special hole for linker synthesis
	or	r29,r29,0		; special hole for linker synthesis
	st	arg0,r0,splimit%	; initial stack limit
	ld	argc,sp,0		; argc
	addu	argv,sp,4		; argv
	or	env,r0,argv		; env
loop:					; search for end of argv
	ld	temp,env,0		; get argv word
	addu	env,env,4
	bcnd	ne0,temp,loop		; test for NIL
	ld	temp,argv,0		; first pointer to arg text
	cmp	temp,env,temp		; pointer to env pointer list
	bb1	lt,temp,no_env
	subu	env,env,4		; no env--point to argv's NIL
no_env:
	st	env,r0,_environ		; save pointer to environment
	and	sp,sp,lo16(-16)		; round to cache line boundary
	subu	sp,sp,16		; allocate space for arguments
;	or	ppi,sp,0	; set up parameter in pointer 880206saj
	st	argc,m_argc		; save argc
	st	argv,m_argv		; save argv
	st	env,m_env		; save env
	bsr	_initfpu		; initialize floating point HW
	ld	argc,m_argc
	ld	argv,m_argv
	ld	env,m_env
	bsr	_main			; main (argc, argv, env);
	bsr	_exit			; exit (main (...));
	data
splimit%:	word	0
_environ:	word	0
;
;		GHSSTUBS.S
;
; This file contains the stubs for the second Silicon test compiler.
; These are used to effect the instructions which cannot be executed
; on the chip. 
;
;   These are
;
; 1) floating point instructions. This compiler does NOT compensate for
;    the lack of these instructions.
; 2) Integer multiply is normally done by the chip in
;    the floating point unit. The above compiler will call functions
;    in this file for these operations.
;
;  The interface for these functions is as below.
;
;	Input	r26,r27
;
;	Output	r27
;	Temporaries for this funtion 	r26 through r30
;	Function is called by bsr so return via jmp r1
;	These functions are intended to be leaf procedures, not to
;	need a stack and not to have to save r1.	
;
;		This file should be appended to the startup file
;		crt0.s. (As of 12/21/87, the compiler will not
;		compensate for the mak,clr,or combination used in
;		bitfield assignments. Opcodes illegal to the assembler
;		"help" will be output instead. This should be watched
;		for when compiling, and will be fixed if a requirement
;		exists.) FIXED AT 01/15/88. (??)
;		The user is relied on not to compile floating
;		point code. 
;		Exception handling during
;		st.d instructions will not be a problem if no floating
;		point is used. Note that all this applies only to code
;		generated by the compiler. Rel 0.5 in particular
;		includes several hand optimized assembly functions
;		which will cause problems. These should be reverted to
;		C compiled versions. 
;
;
        text
	global		$mulghs
$mulghs:
;	or		r28,r0,r27      ; done in bsr.n delay slot
	or		r29,r26,r28	; test for zero
	or		r30,r0,1
	bcnd.n		ne0,r29,gh7mul1
	or		r27,r0,r0
	jmp		r1
gh7mul1:
	bb0		0,r26,gh7mul2
; some think the next add should be an addu 
; they were right   CW/SAJ  1/27/88
	addu		r27,r27,r28
gh7mul2:
	extu		r26,r26,0<1>	; shift right by 1
	bcnd		eq0,r26,gh7mul3
	rot		r28,r28,0<31>
	br.n		gh7mul1
	and.c		r28,r28,r30	; shift left by 1
gh7mul3:
	jmp		r1

	data

;
;		MOTSTUBS.S
;
; This file contains the stubs for the second Silicon test compiler.
; These are used to effect the instructions which cannot be executed
; on the chip. 
;
;   These are
;
; 1) floating point instructions. This compiler does NOT compensate for
;    the lack of these instructions.
; 2) Integer multiply is normally done by the chip in
;    the floating point unit. The above compiler will call functions
;    in this file for these operations.
;
;  The interface for these functions is as below.
;
;	Input	r24,r25
;
;	Output	r24
;	parent function r1 value is saved in r23 DO NOT USE r23!
;	Temporaries for this funtion 	r14 through r22
;	Function is called by bsr so return via jmp r1
;	These functions are intended to be leaf procedures, not to
;	need a stack and not to have to save r1.	
;
;		This file should be appended to the startup file
;		crt0.s. (As of 12/21/87, the compiler will not
;		compensate for the mak,clr,or combination used in
;		bitfield assignments. Opcodes illegal to the assembler
;		"help" will be output instead. This should be watched
;		for when compiling, and will be fixed if a requirement
;		exists.) FIXED AT 01/15/88.
;		The user is relied on not to compile floating
;		point code. 
;		Exception handling during
;		st.d instructions will not be a problem if no floating
;		point is used. Note that all this applies only to code
;		generated by the compiler. Rel 0.5 in particular
;		includes several hand optimized assembly functions
;		which will cause problems. These should be reverted to
;		C compiled versions. 
;
;
        text
	global		$mulmot
$mulmot:
;	or		r22,r0,r24	; done in bsr delay slot
	or		r21,r25,r22	; test for zero
	or		r20,r0,1
	bcnd.n		ne0,r21,motmul1
	or		r24,r0,r0
	jmp.n		r1
	or		r1,r0,r23
motmul1:
	bb0		0,r25,motmul2
; some think the next add should be an addu 
; they were right   CW/SAJ  1/27/88
	addu		r24,r24,r22
motmul2:
	extu		r25,r25,0<1>	; shift right by 1
	bcnd		eq0,r25,motmul3
	rot		r22,r22,0<31>
	br.n		motmul1
	and.c		r22,r22,r20	; shift left by 1
motmul3:
	jmp.n		r1
	or		r1,r0,r23

	data

