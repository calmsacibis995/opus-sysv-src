 ; mcount% is the name of the subroutine that counts function calls
 ; for the prof command.
 ;
	global	mcount%
 ;
;	@(#)crt0.s	6.1 
;
;	M78000 _start(3) Routine
;
;	(C) Copyright 1987 by Motorola Inc.
;
;	Written by: Bob Greiner
;
; _start - interface between Unix process launch and C programs
;
; Input:	r31 - stack pointer register, with formatted data
;		r2 - initial stack limit
;
;	The format of the data on the stack is:
;
;	r2 -->initial stack limit
;
;	r31   -->argc
;	argv -->pointer to the text for the first argv entry
;		pointer to the text for the second argv entry
;		...
;		pointer to the text for the last argv entry
;		NIL
;	env  -->pointer to the text for the first env entry
;		pointer to the text for the second env entry
;		...
;		pointer to the text for the last env entry
;		NIL
;		text for the first argv entry
;		text for the second argv entry
;		...
;		text for the last argv entry
;		text for the first env entry
;		text for the second env entry
;		...
;		text for the last env entry
;
;	or
;
;	r2 -->initial stack limit
;
;	r31   -->argc
;	argv -->pointer to the text for the first argv entry
;		pointer to the text for the second argv entry
;		...
;		pointer to the text for the last argv entry
;	env  -->NIL
;		text for the first argv entry
;		text for the second argv entry
;		...
;		text for the last argv entry
;
;	These two patterns are differentiated by the pointer
;	to the text for the first argv entry pointing immediately
;	after the first NIL.
;
;	Note the implication that argc >= 1, and that argv[0]!=NIL.
;	Thus, the minimum startup data pattern is
;
;	r2 -->initial stack limit
;
;	r31   -->word 1
;	argv -->word argv.0
;	env  -->word 0
;	argv.0->byte 0
;
; Output:	NEVER RETURNS
;
;
;
	text
	global	__start
	global	splimit%
	global	_environ
	global	_initfpu
	global	_exit
	global	_main
;
__start:
	or.u	r26,r0,0		; special hole for linker synthesis
	or	r26,r26,0		; special hole for linker synthesis
	or.u	r27,r0,0		; special hole for linker synthesis
	or	r27,r27,0		; special hole for linker synthesis
	or.u	r28,r0,0		; special hole for linker synthesis
	or	r28,r28,0		; special hole for linker synthesis
	or.u	r29,r0,0		; special hole for linker synthesis
	or	r29,r29,0		; special hole for linker synthesis
	st	r2,r0,splimit%	; initial stack limit
	ld	r2,r31,0		; r2
	addu	r3,r31,4		; r3
	or	r4,r0,r3		; r4
loop:					; search for end of r3
	ld	r5,r4,0		; get r3 word
	addu	r4,r4,4
	bcnd	ne0,r5,loop		; test for NIL
	ld	r5,r3,0		; first pointer to arg text
	cmp	r5,r4,r5		; pointer to r4 pointer list
	bb1	lt,r5,no_env
	subu	r4,r4,4		; no r4--point to r3's NIL
no_env:
	st	r4,r0,_environ		; save pointer to environment
	and	r31,r31,lo16(-16)		; round to cache line boundary
	subu	r31,r31,16		; allocate space for arguments
;	or	r29,r31,0	; set up parameter in pointer 880206saj
	st	r2,r31,0		; save r2
	st	r3,r31,4		; save r3
	st	r4,r31,8		; save r4
	bsr	_initfpu		; initialize floating point HW
	ld	r2,r31,0
	ld	r3,r31,4
	ld	r4,r31,8
	bsr	_main			; main (r2, r3, r4);
	bsr	_exit			; exit (main (...));
	data
splimit%:	word	0
_environ:	word	0
;
;		GHSSTUBS.S
;
; This file contains the stubs for the second Silicon test compiler.
; These are used to effect the instructions which cannot be executed
; on the chip. 
;
;   These are
;
; 1) floating point instructions. This compiler does NOT compensate for
;    the lack of these instructions.
; 2) Integer multiply is normally done by the chip in
;    the floating point unit. The above compiler will call functions
;    in this file for these operations.
;
;  The interface for these functions is as below.
;
;	Input	r26,r27
;
;	Output	r27
;	Temporaries for this funtion 	r26 through r30
;	Function is called by bsr so r1 via jmp r1
;	These functions are intended to be leaf procedures, not to
;	need a stack and not to have to save r1.	
;
;		This file should be appended to the startup file
;		crt0.s. (As of 12/21/87, the compiler will not
;		compensate for the mak,clr,or combination used in
;		bitfield assignments. Opcodes illegal to the assembler
;		"help" will be output instead. This should be watched
;		for when compiling, and will be fixed if a requirement
;		exists.) FIXED AT 01/15/88. (??)
;		The user is relied on not to compile floating
;		point code. 
;		Exception handling during
;		st.d instructions will not be a problem if no floating
;		point is used. Note that all this applies only to code
;		generated by the compiler. Rel 0.5 in particular
;		includes several hand optimized assembly functions
;		which will cause problems. These should be reverted to
;		C compiled versions. 
;
;
        text
	global		$mulghs
$mulghs:
;	or		r28,r0,r27      ; done in bsr.n delay slot
	or		r29,r26,r28	; test for r0
	or		r30,r0,1
	bcnd.n		ne0,r29,gh7mul1
	or		r27,r0,r0
	jmp		r1
gh7mul1:
	bb0		0,r26,gh7mul2
; some think the next add should be an addu 
; they were right   CW/SAJ  1/27/88
	addu		r27,r27,r28
gh7mul2:
	extu		r26,r26,0<1>	; shift right by 1
	bcnd		eq0,r26,gh7mul3
	rot		r28,r28,0<31>
	br.n		gh7mul1
	and.c		r28,r28,r30	; shift left by 1
gh7mul3:
	jmp		r1

	data

;
;		MOTSTUBS.S
;
; This file contains the stubs for the second Silicon test compiler.
; These are used to effect the instructions which cannot be executed
; on the chip. 
;
;   These are
;
; 1) floating point instructions. This compiler does NOT compensate for
;    the lack of these instructions.
; 2) Integer multiply is normally done by the chip in
;    the floating point unit. The above compiler will call functions
;    in this file for these operations.
;
;  The interface for these functions is as below.
;
;	Input	r24,r25
;
;	Output	r24
;	parent function r1 value is saved in r23 DO NOT USE r23!
;	Temporaries for this funtion 	r14 through r22
;	Function is called by bsr so r1 via jmp r1
;	These functions are intended to be leaf procedures, not to
;	need a stack and not to have to save r1.	
;
;		This file should be appended to the startup file
;		crt0.s. (As of 12/21/87, the compiler will not
;		compensate for the mak,clr,or combination used in
;		bitfield assignments. Opcodes illegal to the assembler
;		"help" will be output instead. This should be watched
;		for when compiling, and will be fixed if a requirement
;		exists.) FIXED AT 01/15/88.
;		The user is relied on not to compile floating
;		point code. 
;		Exception handling during
;		st.d instructions will not be a problem if no floating
;		point is used. Note that all this applies only to code
;		generated by the compiler. Rel 0.5 in particular
;		includes several hand optimized assembly functions
;		which will cause problems. These should be reverted to
;		C compiled versions. 
;
;
        text
	global		$mulmot
$mulmot:
;	or		r22,r0,r24	; done in bsr delay slot
	or		r21,r25,r22	; test for r0
	or		r20,r0,1
	bcnd.n		ne0,r21,motmul1
	or		r24,r0,r0
	jmp.n		r1
	or		r1,r0,r23
motmul1:
	bb0		0,r25,motmul2
; some think the next add should be an addu 
; they were right   CW/SAJ  1/27/88
	addu		r24,r24,r22
motmul2:
	extu		r25,r25,0<1>	; shift right by 1
	bcnd		eq0,r25,motmul3
	rot		r22,r22,0<31>
	br.n		motmul1
	and.c		r22,r22,r20	; shift left by 1
motmul3:
	jmp.n		r1
	or		r1,r0,r23

	data

