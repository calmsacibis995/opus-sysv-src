/*
	See the most current revision of the MC88100 and MC88200 chip
	errata sheets for the requirements of this program.
*/
#define TRUE    	1
#define FALSE   	0
/*
	Command line switches
*/
int	ismot = TRUE;		 /*  -g: select Green Hills vs. Mot compiler */
int 	verbose = 0;	 	 /*  -v: put additional comments in output   */
int 	statistics  = FALSE;	 /*  -s: display statistics at end of run    */
int	strip_comments = FALSE;  /*  -c: all comments stripped from output   */
int	dummy_before_ld = FALSE; /*  -q: put dummy load before loads         */
int	trap_before_st = FALSE;	 /*  -p: put traps before stores	     */
int	nop_before_st = FALSE;	 /*  -n: put nop after trap before store     */
int     trap_after_ld = FALSE;   /*  -a: put traps after loads               */
int     nop_after_ld = FALSE;    /*  -k: add nops after traps after loads    */
int	double_st = FALSE;       /*  -d: issue stores twice                  */
int     trap_after_st = FALSE;   /*  -z: put traps after stores              */
int     nop_after_st = FALSE;    /*  -y: put nops after traps after stores   */
int	is_absoft = FALSE;       /*  -f: input generated by FORTRAN compiler */
int	split_loads = FALSE;	/* -l: split ld.d into two ld's */
int	split_stores = FALSE;	/* -b: split st.d into two st's */
int	allow_litsyn = FALSE;   /* -e: enable literal synthesis */
int	nop_before_fmul = TRUE;/* -m: put nop before fmul(e1 cpu and before)*/
/*
			Scratch Registers Available

	Motorola cc:	 r24, r25, r30
        Green Hills cc:	 r26, r27, r28, r29, r30
	Absoft FORTRAN:  r30

	r30 should be used only as a last resort.  r30 is reserved for the
	frame pointer.
*/

static  char	*scratch1;  	/* form scratch register names here */
static  char	*scratch2;	/* at most two needed at present */

#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <varargs.h>
#undef DEBUG
#undef DEBUG1



FILE *fpin, *fpout;	 	/* the sacred in out */

#define LARGE   	50
#define HUGE    	4096    /* this oughta be big enough! */

#define NREGS   	32	/* number of registers in MC88100 */
#define WORDSIZE 	4	/* memory word size in bytes for MC88100 */
#define CACHELINESZ     16      /* cache line size in bytes for MC88200 */

/* values for "arg3_type" */
#define UNKNOWN 0
#define REGISTER 1
#define LABEL 2
#define CONSTANT 3
#define WIDTH 4
#define CHAR 5
#define PSEUDO 6




/*
	I know, there is almost no data hiding (i.e. too many globals) in the 
	design of this program.  

	Some material that is not currently needed has been left in in case
	it is desired in the future.
*/
struct fixup {
	char	*name;		/* opcode match string */
        char    *sufx1;		/* opcode suffix match string */
        char    *sufx2;		/* opcode suffix match string */
	int	(*motfunct)();	/* function to fix opcode (Motorola compiler) */
	int	(*ghsfunct)();	/* function to fix opcode (Green Hills) */
        long    cnt; 		/* statistics count */
};

long	linecount = 0;		/* count of 'as' input lines */

typedef struct {
	long	number;		/* line number */
	char	asline[HUGE];  	/* 'as' input line buffer */
	char    label[LARGE];  	/* optional label field -- includes the : */
	char	*therest;	/* everything but the label */
	char	*allargs;	/* everything past opcode+suffixes */
	char    inst[LARGE];	/* opcode (not including .suffix) */
	char    instname[LARGE];/* opcode plus suffixes  */
	char    instname_p[LARGE];/* opcode plus suffixes -- for printout */
	char    suff1[LARGE];	/* first suffix (no leading . ) */
	char    suff2[LARGE];	/* second suffix (no leading . ) */
	char    suff3[LARGE];	/* third suffix (no leading . ) */
	char    arg1[LARGE];	/* first argument (eg. register designation) */
	char    arg2[LARGE];	/* and so on ... */
	char    arg3[LARGE];  	/* 3rd register, lit16, or W5 */
	char    arg4[LARGE];  	/* <O5> field, if present */
	char    rest[LARGE];    /* end of line or right side comments */
	int	has_label;
	int	has_sufx1;
	int	has_sufx2; 
	int	arg3_type;
	long    const_val;	/* if arg3 is a constant, this is the value */
	int	has_scaling;
	struct fixup *fixit;		
} asrecord ;
asrecord	thisline, nextline;

/*
 	Text location counter
*/
static long location = 0;

static int  in_delayslot = 0;
static char badslot[] = 
           "%s:  FATAL! Attempt expand code in delay slot! file %s line %ld\n";

/*
	Variables used for assembly labels generated by this program
*/
static  unsigned int ilblcnt = 0;
static	char         ilblpfx[]	= "@_s";
/*
   Verbose mode messages
*/
static char beginmsg[] = "; %s:  Begin SiFIX %s\n";
static char endmsg[] = "; %s:  End SiFIX %s\n";

/* 
   fixup action functions  -- may be compiler dependent
*/
extern  int     default_a();	/* the default action per instruction */	
extern  int     delaybr();		
extern	int 	fixst();
extern  int     fixfloat();
extern  int     fixsubu();
extern  int     fixaddu();
extern	int 	fixstd();
extern  int     fixld();
extern	int 	fixldd();
extern  int	litsyn();
extern  int	fmul_fix();


/*
	Try to keep this table sorted (in source) in order of most frequently
        used instructions. (A good idea, not necessarily implemented.)

        This table should now contain an entry for each legitimate 88100
        instruction.  This program will not work correctly if this table
        does not fully and completely reflect the 88100 instruction set
        expressable in the 88100 assembly language.

        In earlier versions of this program, it was important to have
        space in this table for two compiler-dependent action routines.
        This is not presently a requirement, but the table reserves space
        for two action routines.
*/

struct fixup mnemonics[] = {
#if 1
{	"and",	"",	"",	default_a,	default_a,	0},	
{	"and",	"u",	"",	default_a,	default_a,	0},	
{	"and",	"c",	"",	default_a,	default_a,	0},	

{	"or",	"",	"",	default_a,	default_a,	0},	
{	"or",	"u",	"",	default_a,	default_a,	0},	
{	"or",	"c",	"",	default_a,	default_a,	0},	

{	"xor",	"",	"",	default_a,	default_a,	0},	
{	"xor",	"u",	"",	default_a,	default_a,	0},	
{	"xor",	"c",	"",	default_a,	default_a,	0},	

{	"mask",	"",	"",	default_a,	default_a,	0},	
{	"mask",	"u",	"",	default_a,	default_a,	0},	

{	"add",	"",	"",	default_a,	default_a,	0},	
{	"add",	"ci",	"",	default_a,	default_a,	0},	
{	"add",	"co",	"",	default_a,	default_a,	0},	
{	"add",	"cio",	"",	default_a,	default_a,	0},	

{	"sub",	"",	"",	default_a,	default_a,	0},	
{	"sub",	"ci",	"",	default_a,	default_a,	0},	
{	"sub",	"co",	"",	default_a,	default_a,	0},	
{	"sub",	"cio",	"",	default_a,	default_a,	0},	

{	"addu",	"",	"",	default_a,	default_a,	0},	
{	"addu",	"ci",	"",	default_a,	default_a,	0},	
{	"addu",	"co",	"",	default_a,	default_a,	0},	
{	"addu",	"cio",	"",	default_a,	default_a,	0},	

{	"subu",	"",	"",	default_a,	default_a,	0},	
{	"subu",	"ci",	"",	default_a,	default_a,	0},	
{	"subu",	"co",	"",	default_a,	default_a,	0},	
{	"subu",	"cio",	"",	default_a,	default_a,	0},	

{	"mul",	"",	"",	default_a,	default_a,	0},	
{	"div",	"",	"",	default_a,	default_a,	0},	
{	"divu",	"",	"",	default_a,	default_a,	0},	
{	"cmp",	"",	"",	default_a,	default_a,	0},	

{	"clr",	"",	"",	default_a,	default_a,	0},	
{	"ext",	"",	"",	default_a,	default_a,	0},	
{	"extu",	"",	"",	default_a,	default_a,	0},	
{	"ff0",	"",	"",	default_a,	default_a,	0},	
{	"ff1",	"",	"",	default_a,	default_a,	0},	
{	"mak",	"",	"",	default_a,	default_a,	0},	
{	"rot",	"",	"",	default_a,	default_a,	0},	
{	"set",	"",	"",	default_a,	default_a,	0},	

{	"ldcr",	"",	"",	default_a,	default_a,	0},	
{	"stcr",	"",	"",	default_a,	default_a,	0},	
{	"xmem",	"",	"",	default_a,	default_a,	0},	
{	"xmem",	"usr",	"",	default_a,	default_a,	0},	
{	"xmem",	"bu",	"",	default_a,	default_a,	0},	
{	"xmem",	"bu",	"usr",	default_a,	default_a,	0},	
{	"xcr",	"",	"",	default_a,	default_a,	0},	

{	"ld",	"b",	"",	default_a,	default_a,	0},	
{	"ld",	"bu",	"",	default_a,	default_a,	0},	
{	"ld",	"h",	"",	default_a,	default_a,	0},	
{	"ld",	"hu",	"",	default_a,	default_a,	0},	
{	"ld",	"",	"",	default_a,	default_a,	0},	
{	"ld",	"d",	"",	default_a,	default_a,	0},	

{	"lda",	"b",	"",	default_a,	default_a,	0},	
{	"lda",	"h",	"",	default_a,	default_a,	0},	
{	"lda",	"",	"",	default_a,	default_a,	0},	
{	"lda",	"d",	"",	default_a,	default_a,	0},	

{	"ld",	"b",	"usr",	default_a,	default_a,	0},	
{	"ld",	"bu",	"usr",	default_a,	default_a,	0},	
{	"ld",	"h",	"usr",	default_a,	default_a,	0},	
{	"ld",	"hu",	"usr",	default_a,	default_a,	0},	
{	"ld",	"",	"usr",	default_a,	default_a,	0},	
{	"ld",	"d",	"usr",	default_a,	default_a,	0},	

{	"st",	"b",	"",	default_a,	default_a,	0},	
{	"st",	"h",	"",	default_a,	default_a,	0},	
{	"st",	"",	"",	default_a,	default_a,	0},	
{	"st",	"d",	"",	default_a,	default_a,	0},	

{	"st",	"b",	"usr",	default_a,	default_a,	0},	
{	"st",	"h",	"usr",	default_a,	default_a,	0},	
{	"st",	"",	"usr",	default_a,	default_a,	0},	
{	"st",	"d",	"usr",	default_a,	default_a,	0},	

{	"jmp",    "",    "",  default_a, default_a, 0 },
{	"jmp",	  "n",   "",  delaybr,  delaybr,  0   },
{	"jsr",    "",    "",  default_a, default_a, 0 },
{	"jsr",	  "n",   "",  delaybr,  delaybr,  0   },
{	"bb0",    "",    "",  default_a, default_a, 0 },
{	"bb0",	  "n",   "",  delaybr,  delaybr,  0   },
{	"bb1",    "",    "",  default_a, default_a, 0 },
{	"bb1",	  "n",   "",  delaybr,  delaybr,  0   },
{	"bcnd",   "",    "",  default_a, default_a, 0 },
{	"bcnd",	  "n",   "",  delaybr,  delaybr,  0   },
{	"bsr",    "",    "",  default_a, default_a, 0 },
{	"bsr",	  "n",   "",  delaybr,  delaybr,  0   },
{	"br",     "",    "",  default_a, default_a, 0 },
{	"br",	  "n",   "",  delaybr,  delaybr,  0   },

{	"tb0",	"",	"",	default_a,	default_a,	0},	
{	"tb1",	"",	"",	default_a,	default_a,	0},	
{	"tbnd",	"",	"",	default_a,	default_a,	0},	
{	"tcnd",	"",	"",	default_a,	default_a,	0},	
{	"rte",	"",	"",	default_a,	default_a,	0},	

{	"fcmp",	"sss",	"",	default_a,	default_a,	0},	
{	"fcmp",	"ssd",	"",	default_a,	default_a,	0},	
{	"fcmp",	"sds",	"",	default_a,	default_a,	0},	
{	"fcmp",	"sdd",	"",	default_a,	default_a,	0},	

{	"fadd",	"sss",	"",	default_a,	default_a,	0},	
{	"fadd",	"ssd",	"",	default_a,	default_a,	0},	
{	"fadd",	"sds",	"",	default_a,	default_a,	0},	
{	"fadd",	"sdd",	"",	default_a,	default_a,	0},	
{	"fadd",	"dss",	"",	default_a,	default_a,	0},	
{	"fadd",	"dsd",	"",	default_a,	default_a,	0},	
{	"fadd",	"dds",	"",	default_a,	default_a,	0},	
{	"fadd",	"ddd",	"",	default_a,	default_a,	0},	

{	"fsub",	"sss",	"",	default_a,	default_a,	0},	
{	"fsub",	"ssd",	"",	default_a,	default_a,	0},	
{	"fsub",	"sds",	"",	default_a,	default_a,	0},	
{	"fsub",	"sdd",	"",	default_a,	default_a,	0},	
{	"fsub",	"dss",	"",	default_a,	default_a,	0},	
{	"fsub",	"dsd",	"",	default_a,	default_a,	0},	
{	"fsub",	"dds",	"",	default_a,	default_a,	0},	
{	"fsub",	"ddd",	"",	default_a,	default_a,	0},	

{	"fmul",	"sss",	"",	fmul_fix,	fmul_fix,	0},	
{	"fmul",	"ssd",	"",	fmul_fix,	fmul_fix,	0},	
{	"fmul",	"sds",	"",	fmul_fix,	fmul_fix,	0},	
{	"fmul",	"sdd",	"",	fmul_fix,	fmul_fix,	0},	
{	"fmul",	"dss",	"",	fmul_fix,	fmul_fix,	0},	
{	"fmul",	"dsd",	"",	fmul_fix,	fmul_fix,	0},	
{	"fmul",	"dds",	"",	fmul_fix,	fmul_fix,	0},	
{	"fmul",	"ddd",	"",	fmul_fix,	fmul_fix,	0},	

{	"fdiv",	"sss",	"",	default_a,	default_a,	0},	
{	"fdiv",	"ssd",	"",	default_a,	default_a,	0},	
{	"fdiv",	"sds",	"",	default_a,	default_a,	0},	
{	"fdiv",	"sdd",	"",	default_a,	default_a,	0},	
{	"fdiv",	"dss",	"",	default_a,	default_a,	0},	
{	"fdiv",	"dsd",	"",	default_a,	default_a,	0},	
{	"fdiv",	"dds",	"",	default_a,	default_a,	0},	
{	"fdiv",	"ddd",	"",	default_a,	default_a,	0},	

{	"flt",	"ss",	"",	default_a,	default_a,	0},	
{	"flt",	"ds",	"",	default_a,	default_a,	0},	
{	"int",	"ss",	"",	default_a,	default_a,	0},	
{	"int",	"sd",	"",	default_a,	default_a,	0},	
{	"nint",	"ss",	"",	default_a,	default_a,	0},	
{	"nint",	"sd",	"",	default_a,	default_a,	0},	
{	"trnc",	"ss",	"",	default_a,	default_a,	0},	
{	"trnc",	"sd",	"",	default_a,	default_a,	0},	

{	"fldcr",	"",	"",	default_a,	default_a,	0},	
{	"fstcr",	"",	"",	default_a,	default_a,	0},	
{	"fxcr",	"",	"",	default_a,	default_a,	0},	

{	NULL,	"",	"",	default_a,	default_a,	0}
#else
{       "and",    "",    "",  litsyn,  litsyn,  0 },
{       "and",    "u",   "",  litsyn,  litsyn,  0 },
{       "and",    "c",   "",  default_a, default_a, 0 },

{       "or",    "",    "",  litsyn,   litsyn,  0 },
{	"or",    "u",   "",  litsyn,   litsyn,  0 },
{       "or",    "c",   "",  default_a, default_a, 0 },

{       "xor",    "",    "",  litsyn,  litsyn,  0   },
{       "xor",    "u",   "",  litsyn,  litsyn,  0   },
{       "xor",    "c",   "",  default_a, default_a, 0 },

{       "mask",    "",   "",  litsyn,  litsyn,  0 },
{       "mask",    "u",  "",  litsyn,  litsyn,  0 },

{       "add",    "",    "",  litsyn,  litsyn,   0  },
{       "add",    "ci",  "",  default_a, default_a, 0 },
{       "add",    "co",  "",  default_a, default_a, 0 },
{       "add",    "cio", "",  default_a, default_a, 0 },

{       "sub",    "",    "",  litsyn,  litsyn,   0  },
{       "sub",    "ci",  "",  default_a, default_a, 0 },
{       "sub",    "co",  "",  default_a, default_a, 0 },
{       "sub",    "cio", "",  default_a, default_a, 0 },

{       "addu",    "",    "",  fixaddu,    fixaddu,    0  },
{       "addu",    "ci",  "",  default_a, default_a, 0 },
{       "addu",    "co",  "",  default_a, default_a, 0 },
{       "addu",    "cio", "",  default_a, default_a, 0 },

{       "subu",    "",    "",  fixsubu,    fixsubu,    0  },
{       "subu",    "ci",  "",  default_a, default_a, 0 },
{       "subu",    "co",  "",  default_a, default_a, 0 },
{       "subu",    "cio", "",  default_a, default_a, 0 },

{       "mul",    "",    "",  litsyn,  litsyn,   0  },
{       "div",    "",    "",  litsyn,  litsyn,   0  },
{       "divu",    "",    "", litsyn,  litsyn,   0  },
{       "cmp",    "",    "",  litsyn,     litsyn,      0  },

{       "clr",    "",    "",  default_a,  default_a,   0  },
{       "ext",    "",    "",  default_a,  default_a,   0  },
{       "extu",   "",    "",  default_a,  default_a,   0  },
{       "ff0",    "",    "",  default_a,  default_a,   0  },
{       "ff1",    "",    "",  default_a,  default_a,   0  },
{       "mak",    "",    "",  default_a,  default_a,   0  },
{       "rot",    "",    "",  default_a,  default_a,   0  },
{       "set",    "",    "",  default_a,  default_a,   0  },

{       "ldcr",   "",    "",  default_a,  default_a,   0  },
{       "stcr",   "",    "",  default_a,  default_a,   0  },
{       "xmem",   "",    "",  litsyn,  litsyn,   0  },
{	"xmem",   "usr", "",  default_a, default_a, 0 },
{	"xmem",   "bu",  "",  litsyn,  litsyn,   0  },
{	"xmem",   "bu",  "usr", default_a, default_a, 0 },
{       "xcr",    "",    "",  default_a,  default_a,   0  },

{	"ld",	  "b",   "",  fixld,  fixld,  0   }, 
{	"ld",	  "bu",  "",  fixld,  fixld,  0   },
{	"ld",	  "h",   "",  fixld,  fixld,  0   },
{	"ld",	  "hu",  "",  fixld,  fixld,  0   },
{	"ld",	  "",    "",  fixld,  fixld,  0   }, 
{	"ld",	  "d",   "",  fixldd, fixldd, 0   },

{	"lda",	  "b",   "",  litsyn,  litsyn,  0   }, 
{	"lda",	  "h",   "",  litsyn,  litsyn,  0   },
{	"lda",	  "",    "",  litsyn,  litsyn,  0   }, 
{	"lda",	  "d",   "",  litsyn,  litsyn,  0   },

{	"ld",	  "b",   "usr",  fixld,  fixld,  0   }, 
{	"ld",	  "bu",  "usr",  fixld,  fixld,  0   },
{	"ld",	  "h",   "usr",  fixld,  fixld,  0   },
{	"ld",	  "hu",  "usr",  fixld,  fixld,  0   },
{	"ld",	  "",    "usr",  fixld,  fixld,  0   }, 
{	"ld",	  "d",   "usr",  fixldd, fixldd, 0   },

{	"st",	  "b",   "",  fixst,    fixst,    0   },
{	"st",	  "h",   "",  fixst,    fixst,    0   },
{	"st",	  "",    "",  fixst,    fixst,    0   },
{	"st",	  "d",   "",  fixstd,   fixstd,   0   },

{	"st",	  "b",   "usr",  fixst,    fixst,    0   },
{	"st",	  "h",   "usr",  fixst,    fixst,    0   },
{	"st",	  "",    "usr",  fixst,    fixst,    0   },
{	"st",	  "d",   "usr",  fixstd,   fixstd,   0   },

{	"jmp",    "",    "",  default_a, default_a, 0 },
{	"jmp",	  "n",   "",  delaybr,  delaybr,  0   },
{	"jsr",    "",    "",  default_a, default_a, 0 },
{	"jsr",	  "n",   "",  delaybr,  delaybr,  0   },
{	"bb0",    "",    "",  default_a, default_a, 0 },
{	"bb0",	  "n",   "",  delaybr,  delaybr,  0   },
{	"bb1",    "",    "",  default_a, default_a, 0 },
{	"bb1",	  "n",   "",  delaybr,  delaybr,  0   },
{	"bcnd",   "",    "",  default_a, default_a, 0 },
{	"bcnd",	  "n",   "",  delaybr,  delaybr,  0   },
{	"bsr",    "",    "",  default_a, default_a, 0 },
{	"bsr",	  "n",   "",  delaybr,  delaybr,  0   },
{	"br",     "",    "",  default_a, default_a, 0 },
{	"br",	  "n",   "",  delaybr,  delaybr,  0   },

{	"tb0",	  "",   "",   default_a,  default_a,  0   },
{	"tb1",	  "",   "",   default_a,  default_a,  0   },
{	"tbnd",	  "",   "",   default_a,  default_a,  0   },
{	"tcnd",	  "",   "",   default_a,  default_a,  0   },
{	"rte",	  "",   "",   default_a,  default_a,  0   },

{       "fcmp",   "sss", "",  default_a,  default_a,  0   },
{       "fcmp",   "ssd", "",  fixfloat,  fixfloat,  0   },
{       "fcmp",   "sds", "",  fixfloat,  fixfloat,  0   },
{       "fcmp",   "sdd", "",  fixfloat,  fixfloat,  0   },

{       "fadd",   "sss", "",  default_a,  default_a,  0   },
{       "fadd",   "ssd", "",  fixfloat,  fixfloat,  0   },
{       "fadd",   "sds", "",  fixfloat,  fixfloat,  0   },
{       "fadd",   "sdd", "",  fixfloat,  fixfloat,  0   },
{       "fadd",   "dss", "",  default_a,  default_a,  0   },
{       "fadd",   "dsd", "",  fixfloat,  fixfloat,  0   },
{       "fadd",   "dds", "",  fixfloat,  fixfloat,  0   },
{       "fadd",   "ddd", "",  fixfloat,  fixfloat,  0   },

{       "fsub",   "sss", "",  default_a,  default_a,  0   },
{       "fsub",   "ssd", "",  fixfloat,  fixfloat,  0   },
{       "fsub",   "sds", "",  fixfloat,  fixfloat,  0   },
{       "fsub",   "sdd", "",  fixfloat,  fixfloat,  0   },
{       "fsub",   "dss", "",  default_a,  default_a,  0   },
{       "fsub",   "dsd", "",  fixfloat,  fixfloat,  0   },
{       "fsub",   "dds", "",  fixfloat,  fixfloat,  0   },
{       "fsub",   "ddd", "",  fixfloat,  fixfloat,  0   },

{       "fmul",   "sss", "",  default_a,  default_a,  0   },
{       "fmul",   "ssd", "",  fixfloat,  fixfloat,  0   },
{       "fmul",   "sds", "",  fixfloat,  fixfloat,  0   },
{       "fmul",   "sdd", "",  fixfloat,  fixfloat,  0   },
{       "fmul",   "dss", "",  default_a, default_a, 0   },
{       "fmul",   "dsd", "",  fixfloat,  fixfloat,  0   },
{       "fmul",   "dds", "",  fixfloat,  fixfloat,  0   },
{       "fmul",   "ddd", "",  fixfloat,  fixfloat,  0   },

{       "fdiv",   "sss", "",  default_a, default_a, 0   },
{       "fdiv",   "ssd", "",  fixfloat,  fixfloat,  0   },
{       "fdiv",   "sds", "",  fixfloat,  fixfloat,  0   },
{       "fdiv",   "sdd", "",  fixfloat,  fixfloat,  0   },
{       "fdiv",   "dss", "",  default_a, default_a, 0   },
{       "fdiv",   "dsd", "",  fixfloat,  fixfloat,  0   },
{       "fdiv",   "dds", "",  fixfloat,  fixfloat,  0   },
{       "fdiv",   "ddd", "",  fixfloat,  fixfloat,  0   },

{       "flt",    "ss",  "",  default_a,  default_a,  0  },
{       "flt",    "ds",  "",  default_a,  default_a,  0  },
{       "int",    "ss",  "",  default_a,  default_a,  0  },
{       "int",    "sd",  "",  fixfloat,  fixfloat,  0  },
{       "nint",   "ss",  "",  default_a,  default_a,  0  },
{       "nint",   "sd",  "",  fixfloat,  fixfloat,  0  },
{       "trnc",   "ss",  "",  default_a,  default_a,  0  },
{       "trnc",   "sd",  "",  fixfloat,  fixfloat,  0  },

{       "fldcr",  "",    "",  default_a,  default_a,  0  },
{       "fstcr",  "",    "",  default_a,  default_a,  0  },
{       "fxcr",  "",    "",   default_a,  default_a,  0  },

{	NULL,	  "",   "",   NULL,     NULL,     0   }
#endif
};
extern	struct fixup *is_bad_op();

extern	void	itoa();
/*
	nop sequences -- useful in kludging timing problems
*/
static	char	nop[] = "\tor\t\tr0,%s,r0\n";
static	char	trapnop[] = "\ttb1\t\t0,r0,511\n";
static	char	ldnop[] = "%s\t%s\t\tr0,%s,%s\n";
static	char	ldscnop[] = "%s\t%s\t\tr0,%s[%s]\n";
/*
	Command line argument stuff
*/

#define SELF_ARG 0  		/* base zero */
#define SELF_ARG_1 1 		/* base one */
#define INPUT_ARG 0  		/* base zero */
#define INPUT_ARG_1 1 		/* base one */
#define OUTPUT_ARG 1  		/* base zero */
#define OUTPUT_ARG_1 2 		/* base one */
#define MAX_ARG OUTPUT_ARG_1  	/* base zero */
#define MAX_ARG_1 OUTPUT_ARG_1  /* base one */

char	*myname;
#define GHS_SIFILTER "ghs_sifilter"
static char	optstring[] = "ncgvsqpakzydflbem";
static char     too_many_args[] = "%s:  too many arguments\n";
static char     usage[] = "usage:  %s [-%s] [input_file | - ] [output_file]\n";
static char	noopeni[] = "Could not open input file ";
static char	noopeno[] = "Could not open output file ";
char 	*ifnm;

void
main(argc, argv, envp)
int     argc;
char    **argv, **envp;
{
	extern	int	optind;
	extern	int	opterr;
	extern	char	*optarg;
        char	*s;
        char	*ofnm;
        char	c;

        myname = argv[SELF_ARG];
        s = strtok(argv[SELF_ARG], "./");
        while ( s != NULL ) {
           myname = s;
           s = strtok( (char *) NULL, "./");
        }
	if ( strcmp(myname, GHS_SIFILTER) == 0 ) {
           ismot = FALSE;

#if defined DEBUG
	   fprintf(stdout,"ismot set to false; myname is: %s\n",myname);
#endif

        } 
        opterr = 0;
        while ( (c = getopt(argc, argv, optstring)) != -1 ) {
           switch (c) {
           case   'c':	strip_comments = TRUE;
			break;
           case   'g':  ismot = FALSE;
			break;
           case   'v':  ++verbose;
			break; 
	   case   's':  statistics = TRUE;
			break;
           case   'q':  dummy_before_ld = TRUE;
			break;
           case   'p':  trap_before_st = TRUE;
			break;
	   case   'n':  nop_before_st = TRUE;
			trap_before_st = TRUE;  /* NOTE -n sets -p ! */
			break;
           case   'a':  trap_after_ld = TRUE;
                        break;
           case   'k':  nop_after_ld = TRUE;
			break;
           case   'z':  trap_after_st = TRUE;
                        break;
           case   'y':  nop_after_st = TRUE;
                        break;
           case   'd':  double_st = TRUE;
			break;
           case   'f':  is_absoft = TRUE;
			break;
	   case	  'l':	split_loads = TRUE;
			break;
	   case	  'b':	split_stores = TRUE;
			break;
	   case   'e':  allow_litsyn = TRUE;
			break;
	   case   'm':  nop_before_fmul = TRUE;
			break;
           case   '?':  fprintf(stderr, usage, myname, optstring);
			exit(2);
           }
        }

        if ( !ismot && is_absoft ) {
           fprintf(stderr, usage, myname, optstring);
	   exit(2);
        }
        else {
           if ( is_absoft ) {
              ismot = FALSE;
           }
        }

        fpin = stdin;   	/* default */
        fpout = stdout;   	/* default */
        if ( argc == (INPUT_ARG_1+optind) ) {
           openinput(argv, optind);
	}
	else {
           if ( argc == (OUTPUT_ARG_1+optind) ) {
              openinput(argv, optind);
              ofnm = argv[OUTPUT_ARG+optind];
              if ( ofnm[0] != '-' ) {
	         if ( (fpout = fopen(ofnm, "w")) == 0 ) {
	            fprintf(stderr, "%s: %s%s\n", myname, noopeno, ofnm);
	            perror(myname);
	            fclose(fpin);
	            exit(1);
                 }
              }
           }
           else {
              if ( argc >= (MAX_ARG_1+optind) ) {
                 fprintf(stderr, too_many_args, myname);
                 fprintf(stderr, usage, myname, optstring);
	         fclose(fpin);
                 exit(1);
              }
	   }
        }
	doit();
	fclose(fpout);
	fclose(fpin);
        if ( statistics ) {
           showstats();
        }
	exit(0);
}

/*
	openinput:
*/
openinput(argv, optind)
char    **argv;
int	optind;
{
        ifnm = argv[(INPUT_ARG+optind)];
        if ( ifnm[0] != '-' ) {
           if ( (fpin = fopen(ifnm, "r")) == 0 ) {
	      fprintf(stderr,"%s: %s%s\n",myname, noopeni, ifnm);
	      perror(myname);
	      exit(1);
           }
        } 
}

/*
	doit:
*/
doit()
{
	char	*getasline();
        if ( ismot ) {
           scratch1 = "r24";
           scratch2 = "r25";
        }
        else {
           if ( is_absoft ) {
              scratch1 = "r30";
              scratch2 = "BAD";  /* only one scratch reg available */
           }
           else /* not mot cc && not fortran */ {
              scratch1 = "r26";
              scratch2 = "r27";
           }
        }
        location = 0;
	in_delayslot = 0;	/* false */
	while ( (getasline(&thisline)) != NULL ) {
	   if ( thisline.asline[0] == ';' ) { 
	      /* 
                 pass comments directly to output 
              */
	      if ( !strip_comments ) {
	         fprintf(fpout, "%s", thisline.asline);
              }
	      continue;
	   }
	   npname(&thisline);  /* parse input line */
	   if ( thisline.fixit == NULL ) {
	      /* 
	         no fix, pass input to output 
	      */
	      fprintf(fpout, "%s", thisline.asline); 
	   }
           else {
	      form_instname(&thisline);
	      /* fix up output */
              (ismot) ? ((thisline.fixit->motfunct)(&thisline)) 
	              : ((thisline.fixit->ghsfunct)(&thisline));  	
           }
	}
}
/*
	getasline:
*/
char	*
getasline(aline)
asrecord *aline;
{
        aline->number = ++linecount;
	return( (fgets(aline->asline, sizeof(aline->asline), fpin)) );
}

/*
	npname:
*/
npname(aline)
asrecord *aline;
/* 
	this routine pretty much relies on the expectation that
        it is passed a correct 88100 assembly language line.
*/
{
	register char *ptr;
	register char *fill;
        ptr = aline->asline;
#if defined DEBUG
        fprintf(stdout, "DEBUG: line is: %s\n", ptr); 
#endif
        fill = aline->label;
        *fill = '\0';
	aline->has_label = ((isspace(*ptr)) ? FALSE : TRUE);
        if (aline->has_label) {
	   while ( isspace(*ptr) == 0 ) {
              *fill++ = *ptr++;
           }
           *fill = '\0';
        }
#if defined DEBUG
        fprintf(stdout, "DEBUG: label is: %s\n", aline->label); 
#endif
        aline->therest = ptr;
	while ( isspace(*ptr) ) {
           ptr++;
        }
        fill = aline->inst;
        *fill = '\0';
        while ( (isgraph(*ptr)) && (*ptr != '.') ) {
           *fill++ = *ptr++;
        }
        *fill = '\0';

#if defined DEBUG
        fprintf(stdout, "DEBUG: inst is: %s\n", aline->inst);
#endif
        aline->suff1[0] = aline->suff2[0] = '\0';
        aline->has_sufx2 = FALSE;
        aline->has_sufx1 = ((*ptr == '.') ? TRUE : FALSE);
        if ( aline->has_sufx1 ) {
           fill = aline->suff1;
           while ( *ptr == '.' ) {
              ptr++;
           }
           while ( (isgraph(*ptr)) && (*ptr != '.') ) {
              *fill++ = *ptr++;
           }
           *fill ='\0';

#if defined DEBUG
           fprintf(stdout, "DEBUG: suff1 is: %s\n", aline->suff1);
#endif
           aline->has_sufx2 = ((*ptr == '.') ? TRUE : FALSE);
           if ( aline->has_sufx2 ) {
              fill = aline->suff2;
              while ( *ptr == '.' ) {
                 ptr++;
              }
              while ( (isgraph(*ptr)) ) {
                 *fill++ = *ptr++;
              }
              *fill ='\0';

#if defined DEBUG
              fprintf(stdout, "DEBUG: suff2 is: %s\n", aline->suff2); 
#endif
           } 
        }
/*
	Check to see if the recognized opcode (plus suffixes, if any)
        requires fixup action by this program.
*/
        if ( (aline->fixit = (is_bad_op(aline))) == NULL ) {
           return(NULL);
        }
/*
	Skip over white space between opcode (plus suffixes, if any)
	and operand string
*/
	while ( isspace(*ptr) ) {
           ptr++;
        }
	aline->allargs = ptr;
        fill = aline->arg1;
        *fill = '\0';
        while ( (isgraph(*ptr))  && (*ptr != ',') ) {
           *fill++ = *ptr++;
        }
        *fill = '\0';

#if defined DEBUG
        fprintf(stdout, "DEBUG: arg1 is: %s\n", aline->arg1);
#endif
        while ( (*ptr == ',') || (isspace(*ptr)) ) {
           *ptr++;
        }
        fill = aline->arg2;
        *fill = '\0';
        while ( (*ptr != ',') && (*ptr != '[') && (isgraph(*ptr)) ) {
           *fill++ = *ptr++;
        }
        *fill = '\0';

        aline->has_scaling = (*ptr == '[') ? (TRUE) : (FALSE);
#if defined DEBUG
        fprintf(stdout, "DEBUG: arg2 is: %s\n", aline->arg2); 
#endif
        while ( (*ptr == ',') || (*ptr == '[') || (isspace(*ptr)) ) {
           *ptr++;
        }
        fill = aline->arg3;
        *fill = '\0';
        while ( (*ptr != '<') && (*ptr != ']') && (isgraph(*ptr))  ) {
              *fill++ = *ptr++;
        } 
        *fill = '\0';

#if defined DEBUG
        fprintf(stdout, "DEBUG: arg3 is: %s\n", aline->arg3); 
#endif
        aline->arg4[0] = '\0';
        if ( *ptr == '<' ) {
           while ( (*ptr == '<') || (isspace(*ptr)) ) {
              *ptr++;
           }
           fill = aline->arg4;
           while ( (*ptr != '>') && (isgraph(*ptr)) ) {
                 *fill++ = *ptr++;
           } 
           *fill = '\0';

#if defined DEBUG
           fprintf(stdout, "DEBUG: arg4 is: %s\n", aline->arg4); 
#endif
        }
        else {
           if ( *ptr == ']' ) {
              while ( (*ptr == ']') || (isspace(*ptr)) ) {
                 *ptr++;
              }
           }
        }
        fill = aline->rest;
        *fill = '\0';
        while (*ptr != '\0') {
           *fill++ = *ptr++;
        }
        *fill = '\0';

#if defined DEBUG
        fprintf(stdout, "DEBUG: rest is: %s\n", aline->rest);
#endif

	check_arg3(aline);

	return(0);
}

/*
	form_instname:
*/
form_instname(aline)
asrecord *aline;
{
/* 
	form name of instruction to be fixed up -- for display (printout) 
        and for possible internal use  -- values computed in this routine may
        not be used, depending on command line options OR the input
        stream! (CAUTION!).  There is a horrible kludge lurking 
        close to the surface, here.  
*/
        aline->instname[0] = '\0';	/* might as well initialize both */
        aline->instname_p[0] = '\0';	/* strings -- use and display */
        strcat(aline->instname, aline->inst);
        if ( aline->has_sufx1 ) {
           strcat(aline->instname, ".");
           strcat(aline->instname, aline->suff1);
           if ( aline->has_sufx2 ) {
              strcat(aline->instname, ".");
              strcat(aline->instname, aline->suff2);
           }
        }
        strcpy(aline->instname_p, aline->instname);
        if ( (aline->has_scaling) ) {	/* display string, only */
           strcat(aline->instname_p, ", with scaling");
        }
}
/*
	is_bad_op:
*/
struct fixup *
is_bad_op(aline)
asrecord *aline;
{
	register struct fixup *p;      
	p = mnemonics;
   	while ( p->name ) {        
      	   if ( (strcmp(aline->inst, p->name)) == 0 ) {
              if ( aline->has_sufx1 ) {
                 if ( (strcmp(aline->suff1, p->sufx1)) != 0 ) {
                    p++;
                    continue;
                 }
                 else {
                    if ( aline->has_sufx2 ) {
                       if ( (strcmp(aline->suff1, p->sufx1)) != 0 ) {
                          p++;
                          continue;
                       }
                    }
                 }
              }
              return(p);
           }        
           p++;
        }
	return (NULL);                 
}
/*
	BEGIN ACTION routines
*/

/*
	default_a:
*/
default_a(l)
asrecord *l;
{
        addcodeline("%s", l->asline);  /* maintain location counter */
	in_delayslot = 0;
        return(0);
}

/*
	delaybr:
*/
delaybr(aline)
asrecord *aline;
{
	if ( (aline->has_sufx1) && ((strcmp(aline->suff1, "n")) == 0) ) {
/*
	   Next instruction will be in delay slot
*/
	   in_delayslot += 1;
	   if ( in_delayslot > 1 ) {
	      fprintf(stderr, 
                     "%s:  delaybr:  illegal recursion in %s at line %ld\n", 
                     myname, ifnm, linecount);
	      exit(1);
           }
           nextline.fixit = NULL;
           while ( nextline.fixit == NULL ) {
              if ( (getasline(&nextline)) == NULL ) {
	         fprintf(stderr, 
                         "%s:  premature end of file in %s at line %ld\n", 
                          myname, ifnm, linecount);
	         exit(1);
              }
	      if ( nextline.asline[0] == ';' ) { 
	         /* 
                    pass comments directly to output 
                 */
	         if ( !strip_comments ) {
	            fprintf(fpout, "%s", nextline.asline);
                 }
	         continue;
	      }
	      npname(&nextline);  /* parse input line */
	      if ( nextline.fixit == NULL ) {
	         /* 
	            no fix, pass input to output 
	         */
	         fprintf(fpout, "%s", nextline.asline); 
	      }
           } /* end while */
		   if ( nextline.fixit->motfunct != default_a ) {
		      if ( nextline.has_label ) {
			 fprintf(stderr, 
				"%s:  FATAL: delay branch instruction has label\n\
				 in file %s at line %ld\n", 
				myname, ifnm, linecount);
			 exit(1);
		      } 
		      
	/*
		fix next instruction above and in delay slot
	*/
#if 1
		      if ((nop_before_fmul) && (strcmp(nextline.inst,"fmul") == 0)) {
				addcodeline( "%s%s", thisline.label, trapnop);
		      		addcodeline( "%s", aline->therest);
		      		addcodeline( "%s", nextline.asline);
		      } else {
		      		addcodeline( "%s", aline->asline);
		      		addcodeline( "%s", nextline.asline);
				
			}
#else
		      form_instname(&nextline);
		      (ismot) ? ((nextline.fixit->motfunct)(&nextline)) 
			      : ((nextline.fixit->ghsfunct)(&nextline));  	
#endif
			 
		   }
		   else /* instruction does not need to be fixed */ {
		      addcodeline( "%s", aline->asline);
		      addcodeline( "%s", nextline.asline);
		   }
		}
		else /* not a delayed branch */ {
		   addcodeline( "%s", aline->asline);
		}
		in_delayslot = 0;
		return(0);
	}

	/*
		fixsubu:
	*/
	fixsubu(l)
	asrecord *l;
	{
	/*
		Fix up large (>64K) stack allocations.  Ordinarily, the linker
		would do this by adding instructions.  Since we need to know
		the execution time text addresses in order to fix up floating
		point instructions, we need to add the instructions in this
		filter.
	*/
		unsigned int lit;
		char lithalf[LARGE];

		if (  ((strcmp(l->arg1, "r31")) == 0)  /* r31 is the stack pointer */
		   && ((strcmp(l->arg2, "r31")) == 0)
		   && (l->arg3[0] != 'r')
		   && ((lit = (unsigned)(atoi(l->arg3))) > 64*1024 ) ) {
		   if ( in_delayslot ) {
		      fprintf(stderr, "Dying in fixsubu\n");
		      exit(2);
		   }
		   l->fixit->cnt++;
		   if ( verbose ) {
		      fprintf(fpout, beginmsg, myname, l->instname_p);
		      fprintf(fpout, ";%s", l->asline);
		   }
		   itoa(((lit & 0xFFFF0000) >> 16), lithalf);
		   addcodeline(
		   "%s\tor.u\t\t%s,r0,%s\n", l->label, scratch1, lithalf);
		   itoa((lit & 0x0000FFFF), lithalf);
		   addcodeline(
		   "\tor\t\t%s,%s,%s\n", scratch1, scratch1, lithalf);
		   addcodeline(
		   "\tsubu\t\tr31,r31,%s\n", scratch1);
		   if (verbose) {
		      fprintf(fpout, endmsg, myname, l->instname_p);
		   }
		}
		else {
		   litsyn(l);
		}
		in_delayslot = 0;
		return( 0 );
	}
	/*
		fixaddu:
	*/
	fixaddu(l)
	asrecord *l;
	/*
		Fix up large (>64K) stack deallocations.  Ordinarily, the linker
		would do this by adding instructions.  Since we need to know
		the execution time text addresses in order to fix up floating
		point instructions, we need to add the instructions in this
		filter.
	*/
	{
		unsigned int lit;
		char lithalf[LARGE];

		if (  ((strcmp(l->arg1, "r31")) == 0) 
		   && ((strcmp(l->arg2, "r31")) == 0)
		   && (l->arg3[0] != 'r')
		   && ((lit = (unsigned)(atoi(l->arg3))) > 64*1024 ) ) {
		   if ( in_delayslot ) {
		      fprintf(stderr, "Dying in fixaddu\n");
		      exit(1);
		   }
		   l->fixit->cnt++;
		   if ( verbose ) {
		      fprintf(fpout, beginmsg, myname, l->instname_p);
		      fprintf(fpout, ";%s", l->asline);
		   }
		   itoa(((lit & 0xFFFF0000) >> 16), lithalf);
		   addcodeline(
		   "%s\tor.u\t\t%s,r0,%s\n", l->label, scratch1, lithalf);
		   itoa((lit & 0x0000FFFF), lithalf);
		   addcodeline(
		   "\tor\t\t%s,%s,%s\n", scratch1, scratch1, lithalf);
		   addcodeline(
		   "\taddu\t\tr31,r31,%s\n", scratch1);
		   if (verbose) {
		      fprintf(fpout, endmsg, myname, l->instname_p);
		   }
		}
		else {
		   litsyn(l);
		}
		in_delayslot = 0;
		return( 0 );
	}

	/*
		fmul_fix:
	*/
	fmul_fix(l)
	asrecord *l;
	{
		if ((nop_before_fmul) && !in_delayslot && (strcmp(l->inst,"fmul") == 0)) {
			addcodeline( "%s%s", thisline.label, trapnop);
			*thisline.label = '\0';
			addcodeline("%s", thisline.therest);
		} else
			addcodeline("%s", l->asline);
	}
	/*
		fixfloat:
	*/
	fixfloat(l)
	asrecord *l;
	{
	static char m1[] = "%s:  FATAL!  Cannot fix float in delay slot file %s line %ld\n";
		char 	regtmp[LARGE];
		int	thisr, nextr, 	/* register being stored, next register */
			case1, case2;   /* flags for special care cases */
		char    nextr_s[LARGE]; /* ascii string version of nextr */
		long	nextloc;	/* address of instruction following current */

		l->fixit->cnt++;
		if (verbose) {
		   fprintf(fpout, beginmsg, myname, l->instname_p);
		   fprintf(fpout, ";%s", l->asline);
		}
		if ( in_delayslot ) {
#if defined(DEBUG1)
		fprintf(fpout, ";location is: %ld\n", location);
#endif
		   nextloc = location+WORDSIZE;
		   if ( ((nextloc+WORDSIZE) % CACHELINESZ) == 0 ) {
		      if (  (strcmp(thisline.inst, "bb0") == 0)   
			 || (strcmp(thisline.inst, "bb1") == 0)
			 || (strcmp(thisline.inst, "bcnd") == 0) ) {

			case1 = case2 = FALSE;
			thisr = atoi(&(nextline.arg1[1]));
			nextr = (thisr + 1) % NREGS;
			itoa(nextr, nextr_s);
			case1 = (strcmp(thisline.arg2, nextline.arg1) == 0);
			case2 = ((atoi(&(thisline.arg2[1])) == nextr)
				&& (nextline.suff1[0] == 'd'));
			if( case1 || case2 ) {
	/*
				branch condition would be affected if we
				moved floating instruction above branch.
	*/
			    if ( nextline.suff1[0] == 'd' ) {
			       if ( is_absoft ) {
				  fprintf(fpout, m1, myname, ifnm, linecount);
				  fprintf(stderr, m1, myname, ifnm, linecount);
				  exit(2);
			       }
			       else {

				  addcodeline("%s\t%s.%s\t\t%s,%s,%s\n",
				   thisline.label, nextline.inst, nextline.suff1,
				   scratch1, nextline.arg2, nextline.arg3);
				  if( case1 )
				    addcodeline("\tor\t\tr%s,%s,r0\n", 
						 nextr_s, scratch2);
				  else
				    addcodeline("\tor\t\t%s,%s,r0\n", 
						nextline.arg1, scratch1);
				  addcodeline("%s", thisline.therest); /* the branch */
				  if( case1 )
				    addcodeline("\tor\t\t%s,%s,r0\n",
						nextline.arg1, scratch1);
				  else
				    addcodeline("\tor\t\tr%s,%s,r0\n",
						nextr_s, scratch2);
			       }
			    }
			    else /* destination is single precision */ {
			       addcodeline("%s\t%s.%s\t%s,%s,%s\n",
				thisline.label, nextline.inst, nextline.suff1,
				scratch1, nextline.arg2, nextline.arg3);
			       addcodeline("%s", thisline.asline); /* the branch */
			       addcodeline("\tor\t\t%s,%s,r0\n",
				nextline.arg1, scratch1);
			    }
			} /* conditional branch register matches destination */
			else /* conditional branch but no register conflict */ {
	/*
				move instruction above branch; remove delay slot
	*/
			   addcodeline("%s%s", thisline.label, nextline.therest);
			   addcodeline("\t%s\t\t%s,%s,%s\n", 
			    thisline.inst, thisline.arg1, thisline.arg2, 
			    thisline.arg3);
			}
		     } /* conditional branch */ 
		     else /* unconditional branch */ {
	/*
			  move instruction above branch; remove delay slot
	*/
			addcodeline("%s%s", thisline.label, nextline.therest);
			addcodeline("\t%s\t\t%s\n", 
			 thisline.inst, thisline.arg1);
		     }
		   }
		   else /* don't have to move floating instruction */ {
		      addcodeline( "%s", thisline.asline);
		      addcodeline( "%s", nextline.asline);
		   }
		}
		else /* not in delay slot */ {
		   if ( ismot ) {
	/*
		the assembler and linker do not guarrantee that the desired
		alignment will be achieved in the a.out.
	*/
		      fprintf(fpout, "\talign\t\t16\n");
		   }
		   else /* not mot */ {
		      if( ((location+WORDSIZE) % CACHELINESZ) == 0 ) {
			 addcodeline( nop, "r0");
		      }
		   }
		   addcodeline("%s", l->asline);
		}
		if (verbose) {
		   fprintf(fpout, endmsg, myname, l->instname_p);
		}
		in_delayslot = 0;
		return(0);
	}


	/*
		fixst:
	*/
	fixst(l)		
	asrecord *l;
	{
		if ( trap_before_st || trap_after_st || double_st ) {
		   l->fixit->cnt++;
		   if (verbose) {
		      fprintf(fpout, beginmsg, myname, l->instname_p);
		      fprintf(fpout, ";%s", l->asline);
		   }
		   if ( in_delayslot ) {
	/*
		      Print the label of the branch instruction, if any,
		      and the trap nop.
	*/
		      if ( trap_before_st ) {
			addcodeline( "%s%s", thisline.label, trapnop);
			*thisline.label = '\0';
			if( nop_before_st && l->has_scaling )
			  addcodeline(nop, "r0");
			litsyn(l);
		      }
		      else /* not trap_before_st */ {
			addcodeline( "%s%s", thisline.label, l->therest);
			if ( trap_after_st ) {
			   if ( nop_after_st ) {
			      addcodeline( trapnop);
			      if ( !double_st ) {
				 addcodeline( thisline.therest);  /* the branch */
			      }
			      if ( nop_after_st ) {
				 addcodeline( nop, "r0");
			      }
			   }
			   else /* not nop_after_st */ {
			      if ( !double_st ) {
				 addcodeline( thisline.therest);  /* the branch */
			      }
			      addcodeline( trapnop);
			   }
			}
			if ( double_st ) {
			   if ( trap_after_st ) {
			      if ( nop_after_st ) {
				 addcodeline( "%s", l->therest); 
				 addcodeline( trapnop);
				 /* the branch */
				 addcodeline( "%s", thisline.therest);  
				 addcodeline( nop, "r0");
			      }
			      else /* not nop_after_st */ {
				 addcodeline( "%s", l->therest); 
				 /* the branch */
				 addcodeline( "%s", thisline.therest);  
				 addcodeline( trapnop);
			      }
			   }
			   else /* not trap_after_st */ {
	/*
			 Put the second store in the delay slot
	*/
			      addcodeline( "%s", thisline.therest);  /* the branch */
			      addcodeline( "%s", l->therest);
			   }
			}
		      }
		   }
		   else /* not in delay slot */ {
		      if ( trap_before_st ) {
			 addcodeline( "%s%s", l->label, trapnop);
			 *l->label = '\0';
			 if( nop_before_st && l->has_scaling )
			   addcodeline(nop, "r0");
			 litsyn(l);
		      }
		      else {
			  addcodeline( "%s", l->asline);  /* the store */
			  if ( trap_after_st ) {
			     addcodeline( trapnop);
			     if ( nop_after_st ) {
				addcodeline( nop, "r0");
			     }
			  }
			  if ( double_st ) {
			     addcodeline( "%s", l->therest); 
			     if ( trap_after_st ) {
				addcodeline( trapnop);
				if ( nop_after_st ) {
				   addcodeline( nop, "r0");
				}
			     }
			  }
		      }
		   }
		   if (verbose) {
		      fprintf(fpout, endmsg, myname, l->instname_p);
		   }
		}
		else /* not trap_after_st or double_st*/ {
		  litsyn(l);
		}
		in_delayslot = 0;
		return(0);
	}

	/*
		fixld:
	*/
	fixld(l)		
	asrecord *l;
	{
		if ( dummy_before_ld || trap_after_ld ) {
		   l->fixit->cnt++;
		   if (verbose) {
		      fprintf(fpout, beginmsg, myname, l->instname_p);
		      fprintf(fpout, ";%s", l->asline);
		   }
		   if ( in_delayslot ) {
	/*
		      Print the label of the branch instruction, if any,
		      and the load instruction.
	*/
		      if ( dummy_before_ld ) {
				 /* the dummy load */
			 if ( l->has_scaling ) {
			    addcodeline( 
			    ldscnop, thisline.label, l->instname, l->arg2, l->arg3); 
			 }
			 else {
			    addcodeline( 
			    ldnop, thisline.label, l->instname, l->arg2, l->arg3); 
			  }
			  addcodeline( thisline.therest);  /* the branch */
			  addcodeline( "%s", l->therest);  /* the load */
		      }
		      else /* trap_after_ld */ {
			 if ( nop_after_ld ) {
			    addcodeline( "%s%s", thisline.label, l->therest);
			    addcodeline( trapnop);
			    addcodeline( thisline.therest);  /* the branch */
			    addcodeline( nop, "r0");
			 }
			 else  /* not nop_after_ld */ {
			    addcodeline( "%s%s", thisline.label, l->therest);
			    addcodeline( thisline.therest);  /* the branch */
			    addcodeline( trapnop);
			 }
		      }
		   }
		   else /* not in delay slot */ {
		      if ( dummy_before_ld ) {
				 /* the dummy load */
			 if ( l->has_scaling ) {
			    addcodeline( 
			    ldscnop, l->label, l->instname, l->arg2, l->arg3); 
			 }
			 else {
			    addcodeline( 
			    ldnop, l->label, l->instname, l->arg2, l->arg3); 
			 }
			 addcodeline( "%s", l->therest);  /* the load */
		      }
		      else /* trap_after_ld */ {
			 addcodeline( "%s", l->asline);  /* the load */
			 addcodeline( trapnop);
			 if ( nop_after_ld ) {
			    addcodeline( nop, "r0");
			 }
		      }
		   }
		   if (verbose) {
		      fprintf(fpout, endmsg, myname, l->instname_p);
		   }
		}
		else /* not dummy_before_ld or trap_after_ld */ {
		   litsyn(l);
		}
		in_delayslot = 0;
		return(0);
	}
	/*
		fixstd:
	*/
	fixstd(l)
	asrecord *l;
	{
		int 	saveverbose, saveslot;
		int	thisr, nextr; 	/* register being stored, next register */
		
		char    nextr_s[LARGE]; /* ascii string version of nextr */
	/*
		What some folks won't do to keep their source program lines
		less than 80 character positions ...
	*/
	static char m2[] = "%s:  FATAL! st.d opcode input file %s line %ld\n";

		l->fixit->cnt++;
		if (verbose) {
		   fprintf(fpout, beginmsg, myname, l->instname_p);
		   fprintf(fpout, ";%s", l->asline);
		}
		if ( l->has_sufx2 ) /* bad -- .usr */ {
		   fprintf(fpout, m2, myname, ifnm, linecount);
		   fprintf(stderr, m2, myname, ifnm, linecount);
		   exit(1);
		}
		if ( split_stores) {
	/*
		determine  second  "source" register
	*/
		   thisr = atoi(&(l->arg1[1]));
		   nextr = (thisr + 1) % NREGS;  /* wraparound if req'd */
		   itoa( nextr, nextr_s );
		   if ( in_delayslot ) {
		      fprintf(fpout, "%s", thisline.label);
		      thisline.label[0] = '\0';
		   }
		   else {
		      fprintf(fpout, "%s", l->label);
		      l->label[0] = '\0';
		   }
		   if ( l->has_scaling ) {
	/*
		multiply scaling register contents by sizeof(double)
	*/
		    addcodeline(
		    "\tmak\t\t%s,%s,0<3>\n", scratch1, l->arg3);
		    if ( trap_before_st ) {
		      addcodeline( trapnop);
		      addcodeline(
		      "\t%s\t\t%s,%s,%s\n", l->inst, l->arg1,l-> arg2, scratch1);
		    }
		    else {
		       addcodeline(
		       "\t%s\t\t%s,%s,%s\n", l->inst, l->arg1,l-> arg2, scratch1);
		       if ( trap_after_st ) {
			  addcodeline( trapnop);
			  if ( nop_after_st ) {
			     addcodeline( nop, "r0");
			  }
		       }
		       if ( double_st ) {
			  addcodeline(
			  "\t%s\t\t%s,%s,%s\n", l->inst, l->arg1, l->arg2, scratch1);
			  if ( trap_after_st ) {
			     addcodeline( trapnop);
			     if ( nop_after_st ) {
				addcodeline( nop, "r0");
			     }
			  }
		       }  
		    }  
	/* 
		advance st destination address to next word
	*/
		      addcodeline(
		      "\taddu\t\t%s,%s,4\n", scratch1, scratch1);
		      strcpy(l->arg1, "r");
		      strcat(l->arg1, nextr_s);
		      strcpy(l->arg3, scratch1);
		      strcpy(l->asline, "\t");
		      strcat(l->asline, l->inst);
		      strcat(l->asline, "\t\t");
		      l->allargs = l->asline + strlen(l->asline);
		      strcat(l->asline, l->arg1);
		      strcat(l->asline, ",");
		      strcat(l->asline, l->arg2);
		      strcat(l->asline, ",");
		      strcat(l->asline, l->arg3);
		      strcat(l->asline, "\n");
	/*              strcat(l->asline, l->rest); */
		      saveverbose = verbose;
		      if( verbose < 2 ) {
			verbose = 0;
		      }
		      strcpy(l->instname, "st");
		      l->therest = l->asline;
		      l->has_scaling = FALSE;
		      fixst(l);
		      verbose = saveverbose;
		   }
		   else /* !(has_scaling) */ {
		      if ( trap_before_st ) {
			 strcpy(l->instname, "st");
			 saveslot = in_delayslot;
			 in_delayslot = 0;
			 fixst(l);
			 in_delayslot = saveslot;
		      }
		      else {
			 strcpy(l->instname, "st");
			 saveslot = in_delayslot;
			 in_delayslot = 0;
			 fixst(l);
			 in_delayslot = saveslot;
			 if ( trap_after_st ) {
			    addcodeline( trapnop);
			    if ( nop_after_st ) {
			       addcodeline( nop, "r0");
			    }
			 }
			 if ( double_st ) {
			    addcodeline(
			    "\t%s\t\t%s,%s,%s\n",  l->inst, l->arg1, l->arg2, l->arg3);
			    if ( trap_after_st ) {
			       addcodeline( trapnop);
			       if ( nop_after_st ) {
				  addcodeline( nop, "r0");
			       }
			    }
			 }
		      }
		      if ( l->arg3_type == REGISTER  ) {
	/* 
		advance st destination address to next word
	*/
			 addcodeline(
			 "\taddu\t\t%s,%s,4\n", scratch1, l->arg3);
			 strcpy(l->arg1, "r");
			 strcat(l->arg1, nextr_s);
			 strcpy(l->arg3, scratch1);
			 strcpy(l->asline, "\t");
			 strcat(l->asline, l->inst);
			 strcat(l->asline, "\t\t");
			 l->allargs = l->asline + strlen(l->asline);
			 strcat(l->asline, l->arg1);
			 strcat(l->asline, ",");
			 strcat(l->asline, l->arg2);
			 strcat(l->asline, ",");
			 strcat(l->asline, l->arg3);
			 strcat(l->asline, l->rest);
			 saveverbose = verbose;
			 if( verbose < 2 ) {
			   verbose = 0;
			 }
			 strcpy(l->instname, "st");
			 l->therest = l->asline;
			 fixst(l);
			 verbose = saveverbose;
		      }
		      else /* <lit16> */ {
	/*
		let 'as' fix up the destination address for the second st!
	*/
			 strcpy(l->arg1, "r");
			 strcat(l->arg1, nextr_s);
			 strcat(l->arg3, "+4");
			 strcpy(l->asline, "\t");
			 strcat(l->asline, l->inst);
			 strcat(l->asline, "\t\t");
			 l->allargs = l->asline + strlen(l->asline);
			 strcat(l->asline, l->arg1);
			 strcat(l->asline, ",");
			 strcat(l->asline, l->arg2);
			 strcat(l->asline, ",");
			 strcat(l->asline, l->arg3);
			 strcat(l->asline, l->rest);
			 saveverbose = verbose;
			 if( verbose < 2 ) {
			   verbose = 0;
			 }
			 strcpy(l->instname, "st");
			 l->therest = l->asline;
			 fixst(l);
			 verbose = saveverbose;
		      }
		   }
		}
		else {  /* NOT splitting stores */
		   if( in_delayslot ) {
		     fprintf(fpout, "%s", thisline.label);
		     thisline.label[0] = '\0';
		   }
		   fixst(l);	/* do trap before, nop after, or whatever */
		}
		if (verbose) {
		   fprintf(fpout, endmsg, myname, l->instname_p);
		}
		return(0);
	}

	/*
		fixldd:
	*/
	fixldd(l)
	asrecord *l;
	{
		int 	saveverbose;
		int	thisr, nextr; 	/* register being stored, next register */
		
		char    nextr_s[LARGE]; /* ascii string version of nextr */
		char    strarg3[LARGE];

	/*
		What some folks won't do to keep their source program lines
		less than 80 character positions ...
	*/
	static char m2[] = "%s:  FATAL! ld.d opcode input file %s line %ld\n";
		if (l->arg3[0] == 'l' && l->arg3[1] == 'o') {
		strcpy(strarg3, l->arg3);
		strarg3[0]='h';
		strarg3[1]='i'; 
		      addcodeline(
		      "\tor.u\t\t%s,%s,%s\n", "r29", "r0", strarg3);
		strcpy(l->arg2, "r29");
	}
		l->fixit->cnt++;
		if (verbose) {
		   fprintf(fpout, beginmsg, myname, l->instname_p);
		   fprintf(fpout, ";%s", l->asline);
		}
		if ( l->has_sufx2 ) /* bad -- .usr */ {
		   fprintf(fpout, m2, myname, ifnm, linecount);
		   fprintf(stderr, m2, myname, ifnm, linecount);
		   exit(1);
		}
		else {
	/*
		determine  second  "source" register
	*/
		   thisr = atoi(&(l->arg1[1]));
		   nextr = (thisr + 1) % NREGS;  /* wraparound if req'd */
		   itoa( nextr, nextr_s );
		   if ( in_delayslot ) {
		      fprintf(fpout, "%s\t", thisline.label);
		      thisline.label[0] = '\0';
		   }
		   else {
		      fprintf(fpout, "%s\t", l->label);
		      l->label[0] = '\0';
		   }
		   if ( l->has_scaling ) {
	/*
		multiply scaling register contents by sizeof(double)
	*/
		      addcodeline(
		      "mak\t\t%s,%s,0<3>\n", scratch1, l->arg3);
		      if ( dummy_before_ld ) {
			 addcodeline( ldnop, "", l->inst, l->arg2, scratch1); 
			 addcodeline(
			 "\t%s\t\t%s,%s,%s\n", l->inst, l->arg1, l->arg2, scratch1);
		       }
		       else /* not dummy_before_ld */ {
			 addcodeline(
			 "\t%s\t\t%s,%s,%s\n", l->inst, l->arg1, l->arg2, scratch1);
			  if ( trap_after_ld ) {
			     addcodeline( trapnop, l->arg1);
			     if ( nop_after_ld ) {
				addcodeline( nop, "r0");
			     }
			  }
		       }
	/* 
		advance ld destination address to next word
	*/
		      addcodeline(
		      "\taddu\t\t%s,%s,4\n", scratch1, scratch1);
		      strcpy(l->arg3, scratch1);
		      strcpy(l->arg1, "r");
		      strcat(l->arg1, nextr_s);
		      strcpy(l->asline, "\t");
		      strcat(l->asline, l->inst);
		      strcat(l->asline, "\t\t");
		      l->allargs = l->asline + strlen(l->asline);
		      strcat(l->asline, l->arg1);
		      strcat(l->asline, ",");
		      strcat(l->asline, l->arg2);
		      strcat(l->asline, ",");
		      strcat(l->asline, l->arg3);
		      strcat(l->asline, "\n");
	/*              strcat(l->asline, l->rest); */
		      saveverbose = verbose;
		      verbose = FALSE;
		      strcpy(l->instname,"ld");
		      fixld(l);
		      verbose = saveverbose;
		   }
		   else /* !(has_scaling) */ {
		      if ( dummy_before_ld ) {
				 /* the dummy load */
			  addcodeline( ldnop, "", l->inst, l->arg2, l->arg3); 
			  addcodeline(
			  "%s\t\t%s,%s,%s\n", l->inst, l->arg1, l->arg2, l->arg3);
	/* PEG - added following code */
			 if ( trap_after_ld ) {
			    addcodeline( trapnop, l->arg1);
			    if ( nop_after_ld ) {
			       addcodeline( nop, "r0");
			    }
			 }
		      }
		      else /* not dummy_before_ld */ {
			 addcodeline(
			 "%s\t\t%s,%s,%s\n", l->inst, l->arg1, l->arg2, l->arg3);
			 if ( trap_after_ld ) {
			    addcodeline( trapnop, l->arg1);
			    if ( nop_after_ld ) {
			       addcodeline( nop, "r0");
			    }
			 }
		      }
		      if ( l->arg3[0] == 'r' ) {
	/* 
		advance ld destination address to next word
	*/
			 addcodeline(
			 "\taddu\t\t%s,%s,4\n", scratch1, l->arg3);
			 strcpy(l->arg3, scratch1);
			 strcpy(l->arg1, "r");
			 strcat(l->arg1, nextr_s);
			 strcpy(l->asline, "\t");
			 strcat(l->asline, l->inst);
			 strcat(l->asline, "\t\t");
			 l->allargs = l->asline + strlen(l->asline);
			 strcat(l->asline, l->arg1);
			 strcat(l->asline, ",");
			 strcat(l->asline, l->arg2);
			 strcat(l->asline, ",");
			 strcat(l->asline, l->arg3);
			 strcat(l->asline, l->rest);
			 saveverbose = verbose;
			 verbose = FALSE;
			 strcpy(l->instname,"ld");
			 fixld(l);
			 verbose = saveverbose;
		      }
		      else /* <lit16> */ {
	/*
		let 'as' fix up the destination address for the second st!
	*/
			 strcpy(l->arg1, "r");
			 strcat(l->arg1, nextr_s);
			 strcat(l->arg3, "+4");
			 strcpy(l->asline, "\t");
			 strcat(l->asline, l->inst);
			 strcat(l->asline, "\t\t");
			 l->allargs = l->asline + strlen(l->asline);
			 strcat(l->asline, l->arg1);
			 strcat(l->asline, ",");
			 strcat(l->asline, l->arg2);
			 strcat(l->asline, ",");
			 strcat(l->asline, l->arg3);
			 strcat(l->asline, l->rest);
			 saveverbose = verbose;
			 verbose = FALSE;
			 strcpy(l->instname,"ld");
			 fixld(l);
			 verbose = saveverbose;
		      }
		   }
		}
		if (verbose) {
		   fprintf(fpout, endmsg, myname, l->instname_p);
		}
		return(0);
	}
#if 0
	/*
		fixldd:
	*/
	fixldd(l)
	asrecord *l;
	{
		int 	saveverbose, saveslot;
		int	thisr, nextr; 	/* register being stored, next register */
		int	form_A, form_B, form_C;  /* special case flags */
		
		char    nextr_s[LARGE]; /* ascii string version of nextr */
		char	*middle_reg, *first_reg;  /* char ptr temps */
		char	tregnm[LARGE];  /* used to build a reg name */

	/*
		What some folks won't do to keep their source program lines
		less than 80 character positions ...
	*/
	static char m2[] = "%s:  FATAL! ld.d opcode input file %s line %ld\n";
	static char m3[] = "%s:  FATAL! need 2 scratch registers, file %s line %ld\n";

		l->fixit->cnt++;
		if (verbose) {
		   fprintf(fpout, beginmsg, myname, l->instname_p);
		   fprintf(fpout, ";%s", l->asline);
		}
		if ( l->has_sufx2 ) /* bad -- .usr */ {
		   fprintf(fpout, m2, myname, ifnm, linecount);
		   fprintf(stderr, m2, myname, ifnm, linecount);
		   exit(1);
		}
		if( split_loads ) {

		   /* check for one of the following special cases:

			scaling:

				ld.d	ra,ra[rx]	("form A")
				ld.d	ra,rx[ra]	("form B")
				ld.d	ra,ra[ra]	("form C")

			3-register:

				ld.d	ra,ra,rx	("form A")
				ld.d	ra,rx,ra	("form B")
				ld.d	ra,ra,ra	("form C")

			immediate:

				ld.d	ra,ra,imm	("form A")

		      any one of these requires special precautions when we
		      are splitting the load to avoid overwriting a register
		      in the first half that we will need in the second half */

		      form_A = form_B = form_C = FALSE;

		      if( strcmp(l->arg1, l->arg2) == 0 ) {
			if( strcmp(l->arg1, l->arg3) == 0 ) 
			  form_C = TRUE;
			else form_A = TRUE;
		      }
		      else {
			if( strcmp(l->arg1, l->arg3) == 0 )
			  form_B = TRUE;
		      }

		   /* determine  second  "source" register */

		   thisr = atoi(&(l->arg1[1]));
		   nextr = (thisr + 1) % NREGS;  /* wraparound if req'd */
		   itoa( nextr, nextr_s );
		   if ( in_delayslot ) {
		      fprintf(fpout, "%s\t", thisline.label);
		      thisline.label[0] = '\0';
		   }
		   else {
		      fprintf(fpout, "%s\t", l->label);
		      l->label[0] = '\0'; 
		   }
		   if ( l->has_scaling ) {

		      /* select proper register as source for "mak" */
		      if( form_A ) {
			if( is_absoft ) {  /* must have 2 scratch regs for form A */
			  fprintf(fpout, m3, myname, ifnm, linecount);
			  fprintf(stderr, m3, myname, ifnm, linecount);
			  exit(2);
			}
			else  middle_reg = l->arg3;
		      }
		      else {
			if( form_B || form_C )
			  middle_reg = l->arg1;
			else
			  middle_reg = l->arg3;
		      }

		      /* now we can emit the "mak", which multiplies the scaling
			 register contents by 8				*/

		      addcodeline("mak\t\t%s,%s,0<3>\n", scratch1, middle_reg);

		      /* forms A and C need to have the target saved during 
			 the first half of the split load	*/

		      if( form_A || form_C ) {
			if( form_A )
			  first_reg = scratch2;
			else {
			  strcpy(tregnm, "r");
			  strcat(tregnm, nextr_s);
			  first_reg = tregnm;
			}
			addcodeline("\tor\t\t%s,r0,%s\n", first_reg, l->arg1);
		      }

		      /* select proper source reg for first half of load */

		      if( form_A || form_C )
			middle_reg = l->arg1;
		      else
			middle_reg = l->arg2;

		      if ( dummy_before_ld ) {
			 addcodeline( ldnop, "", l->inst, middle_reg, scratch1); 
			 addcodeline(
			 "\t%s\t\t%s,%s,%s\n", l->inst, l->arg1, middle_reg, scratch1);
		       }
		       else /* not dummy_before_ld */ {
			 addcodeline(
			 "\t%s\t\t%s,%s,%s\n", l->inst, l->arg1, middle_reg, scratch1);
			  if ( trap_after_ld ) {
			     addcodeline( trapnop ) ;
			     if ( nop_after_ld ) {
				addcodeline( nop, "r0");
			     }
			  }
		       }
	/* 
		advance ld destination address to next word
	*/
		      addcodeline(
		      "\taddu\t\t%s,%s,4\n", scratch1, scratch1);
		      strcpy(l->arg3, scratch1);
		      strcpy(l->arg1, "r");
		      strcat(l->arg1, nextr_s);
		      strcpy(l->asline, "\t");
		      strcat(l->asline, l->inst);
		      strcat(l->asline, "\t\t");
		      l->allargs = l->asline + strlen(l->asline);
		      strcat(l->asline, l->arg1);
		      strcat(l->asline, ",");
		      /* select proper source1 reg for second half of load */
		      if( form_A ) {
			strcpy(l->arg2, scratch2);
		      }
		      else {
			if( form_C ) {
			  strcpy(l->arg2, "r");
			  strcat(l->arg2, nextr_s);
			}
		      } /* for other cases, l->arg2 is already correct */
		      strcat(l->asline, l->arg2);
		      strcat(l->asline, ",");
		      strcat(l->asline, l->arg3);
		      strcat(l->asline, "\n");
	/*              strcat(l->asline, l->rest); */
		      saveverbose = verbose;
		      if( verbose < 2 ) {
			verbose = 0;
		      }
		      strcpy(l->instname,"ld");
		      l->has_scaling = FALSE;
		      l->therest = l->asline;
		      fixld(l);
		      verbose = saveverbose;
		   }
		   else /* !(has_scaling) */ {
		      /* if we have an immediate form (ld.d rd,rs,label) with rd==rs,
			 rs would be clobbered by the first half of the split load, so
			 we need to emit an instruction to save a copy of rs here */
		      if( ((l->arg3_type == LABEL) || (l->arg3_type == CONSTANT))
			   &&  form_A ) {
			/* note that in this type of instruction, it is always safe
			   to use the second register of the target pair to hide
			   a copy of the source register, so a scratch is not needed */
			addcodeline("or\t\tr%s,r0,%s\n", nextr_s, l->arg1);
		      }
		      /* special forms need their dest reg saved at this point */
		      if( (form_A || form_B || form_C) 
			&&  ((l->arg3_type == REGISTER) || (l->arg3_type == WIDTH)) ) {
			if( form_C ) { /* OK to use second half of dest as scratch */
			  strcpy(tregnm, "r");
			  strcat(tregnm, nextr_s);
			  first_reg = tregnm;
			}
			else { /* must use 2 scratch registers */
			  first_reg = scratch2;
			  if( is_absoft ) { /* Absoft can't cut it! */
			    fprintf(fpout, m3, myname, ifnm, linecount);
			    fprintf(stderr, m3, myname, ifnm, linecount);
			    exit(2);
			  }
			}
			addcodeline("\tor\t\t%s,r0,%s\n", first_reg, l->arg1);
		      }

		      if ( dummy_before_ld ) {
				 /* the dummy load */
			  addcodeline( ldnop, "", l->inst, l->arg2, l->arg3); 
			  addcodeline(
			  "\t%s\t\t%s,%s,%s\n", l->inst, l->arg1, l->arg2, l->arg3);
		      }
		      else /* not dummy_before_ld */ {
			 strcpy(l->instname, "ld");
			 saveslot = in_delayslot;
			 in_delayslot = 0;
			 fixld(l);
			 in_delayslot = saveslot;
			 if ( trap_after_ld ) {
			    addcodeline( trapnop );
			    if ( nop_after_ld ) {
			       addcodeline( nop, "r0");
			    }
			 }
		      }
		      if ( l->arg3_type == REGISTER ) {   /* this is the 3-reg form */
	/* 
		advance ld destination address to next word
	*/
			 /* select proper source reg for addu */
			 if( form_B )
			   middle_reg = scratch2;
			 else {
			   if( form_C ) {
			     strcpy(tregnm, "r");
			     strcat(tregnm, nextr_s);
			     middle_reg = tregnm;
			   }
			   else middle_reg = l->arg3;
			 }
			 addcodeline(
			 "\taddu\t\t%s,%s,4\n", scratch1, middle_reg);
			 strcpy(l->arg3, scratch1);
			 strcpy(l->arg1, "r");
			 strcat(l->arg1, nextr_s);
			 strcpy(l->asline, "\t");
			 strcat(l->asline, l->inst);
			 strcat(l->asline, "\t\t");
			 l->allargs = l->asline + strlen(l->asline);
			 strcat(l->asline, l->arg1);
			 strcat(l->asline, ",");
			 /* select proper source1 reg for 2nd half of load */
			 if( form_A  ) 
			   strcpy(l->arg2, scratch2);
			 else {
			   if( form_C ) {
			     strcpy(l->arg2, "r");
			     strcat(l->arg2, nextr_s);
			   }
			 }
			 strcat(l->asline, l->arg2);
			 strcat(l->asline, ",");
			 strcat(l->asline, l->arg3);
			 strcat(l->asline, l->rest);
			 saveverbose = verbose;
			 if( verbose < 2 ) {
			   verbose = 0;
			 }
			 l->therest = l->asline;
			 strcpy(l->instname,"ld");
			 fixld(l);
			 verbose = saveverbose;
		      }
		      else /* <lit16> */ {
	/*
		let 'as' fix up the destination address for the second ld!
	*/
			 if( form_A ) {
			   /* substitute temp reg for source arg */
			   strcpy(l->arg2, "r");
			   strcat(l->arg2, nextr_s);
			 }
			 strcpy(l->arg1, "r");
			 strcat(l->arg1, nextr_s);
			 strcat(l->arg3, "+4");
			 strcpy(l->asline, "\t");
			 strcat(l->asline, l->inst);
			 strcat(l->asline, "\t\t");
			 l->allargs = l->asline + strlen(l->asline);
			 strcat(l->asline, l->arg1);
			 strcat(l->asline, ",");
			 strcat(l->asline, l->arg2);
			 strcat(l->asline, ",");
			 strcat(l->asline, l->arg3);
			 strcat(l->asline, l->rest);
			 saveverbose = verbose;
			 if( verbose < 2 ) {
			   verbose = 0;
			 }
			 strcpy(l->instname,"ld");
			 l->therest = l->asline;
			 fixld(l);
			 verbose = saveverbose;
		      }
		   }
		}
		else {  /* NOT splitting ld.d's */
		   if( in_delayslot )  {
		     fprintf(fpout, "%s", thisline.label);
		     thisline.label[0] = '\0';
		   }
		   fixld(l);   /* do load before, trap after or whatever */
		}
		if (verbose) {
		   fprintf(fpout, endmsg, myname, l->instname_p);
		}
		return(0);
	}

#endif






	/*
		litsyn

		literal synthesis
	*/

	litsyn(l)
	asrecord  *l;
	{
	   /* the "cat" arrays are the lists of instructions in each of the
	      three different literal synthesis categories - MUST BE SORTED !!!  */

	   static char  *cat1[] = { "add", "addu", "ld", "lda", "or",
				    "st", "xmem", "xor" };
#define NCAT1 8
	   static char  *cat2[] = { "and", "cmp", "div", "divu", "mask", "mul",
				    "sub", "subu", "tbnd" };
#define NCAT2 9
	   static char  *cat3[] = { "bb0", "bb1", "bcnd" };
#define NCAT3 3

	   int  is_cat1, is_cat2, is_cat3;  /* flags for membership in above */
	   int  needs_litsyn = FALSE;  /* meets other requirements */

	   
	   /* first we check the current instruction for membership in one of
	      the three categories. if it isn't in any, we are done	     */

	   is_cat1 = is_cat2 = is_cat3 = FALSE;

	   is_cat1 = search(l->inst, cat1, NCAT1);
	   is_cat2 = search(l->inst, cat2, NCAT2);
	   is_cat3 = search(l->inst, cat3, NCAT3);


	   /* even if an instruction is in one of the three categories, we don't
	      act on it unless arg3 is a label or a constant > 0xffff		*/

	   if( is_cat1  ||  is_cat2  ||  is_cat3 ) {

	     if( l->arg3_type == LABEL )
	       needs_litsyn = TRUE;
	     else 
	       if( (l->arg3_type == CONSTANT) && (l->const_val > 0xffff) )
		 needs_litsyn = TRUE;
	   }

	   needs_litsyn = (allow_litsyn ? needs_litsyn : FALSE);

	   if( !needs_litsyn ) {  /* no synthesis needed */

	     if( in_delayslot  )  {   /* emit branch here */
		addcodeline("%s\t%s\n", thisline.label, thisline.therest);
		in_delayslot = 0;
	     }

	     /* just pass this line through, maintaining location counter */

	     addcodeline("%s\t%s\t\t%s\n", l->label, l->instname, l->allargs);
	     return;
	   }

	   if( verbose > 0 ) {

	     fprintf(fpout, beginmsg, myname, l->instname_p);
	     fprintf(fpout, ";%s", l->asline);
	   }

	   l->fixit->cnt++;

	   if( is_cat1  ||  is_cat2 )  {

	     /* fixup for cat1 and cat2 instructions is:

			general case:

				or.u	r29,r0,hi16(arg3)
				or	r29,r29,lo16(arg3)
				inst	rd,rs,r29

			special case where rs is r0, and cat1:

				or.u	r29,r0,hi16(arg3)
				inst	rd,r29,lo16(arg3)
	     */

	     /* take care of the label, if any */

	     if( in_delayslot  &&  thisline.has_label )
		fprintf(fpout, "%s", thisline.label);
	     else if( l->has_label )
		fprintf(fpout, "%s", l->label);


	     addcodeline("\tor.u\t\tr29,r0,hi16(%s)\n", l->arg3);  /* the common or.u */

	     if( is_cat1  &&  (strcmp(l->arg2, "r0") == 0) ) {

		/* the special case */

	       if( in_delayslot ) {   /* emit the branch now */
		 addcodeline("\t%s", thisline.therest);
		 in_delayslot = 0;
	       }

	       addcodeline("\t%s\t\t%s,r29,lo16(%s)\n", l->instname, l->arg1, l->arg3);

	     }
	     else {

	       addcodeline("\tor\t\tr29,r29,lo16(%s)\n", l->arg3);

	       if( in_delayslot )  {  /* emit the branch now */
		 addcodeline("\t%s", thisline.therest);
		 in_delayslot = 0;
	       }
	       addcodeline("\t%s\t\t%s,%s,r29\n", l->instname, l->arg1, l->arg2);
	     }
	   }
	   else {  /* this is category 3 */

	     ;  /* BRANCH FIXES GO HERE */

	   }

	   if( verbose > 0 ) 
	     fprintf(fpout, endmsg, myname, l->instname_p);

	}










	/*
		END ACTION routines
	*/

	/*
		BEGIN COMMON routines
	*/
	/*
		addcodeline:
	*/
	addcodeline(va_alist) 
	va_dcl
	{
		va_list ap;
		char    *fmt;
		va_start(ap);
		fmt = va_arg(ap, char *);
		if( verbose > 1 ) {
		  fprintf(fpout, ";Location: %08d\n", location);
		}
		location += WORDSIZE;
		vfprintf(fpout, fmt, ap);
		va_end(ap);
	}







	/*
		check_arg3
	*/

	check_arg3(l)
	asrecord  *l;
	{

	  /* evaluates third argument (if any) to see whether it is a register
	     name, a label, or a constant. returns:


		if arg3 is a valid register name:

			l->arg3_type = REGISTER;
			l->const_val = 0;

		if arg3 is a pseudo-op which is valid as an argument:

			l->arg3_type = PSEUDO;
			l->const_val = 0;

		if arg3 is a label:

			l->arg3_type = LABEL;
			l->const_val = 0;

		if arg3 is a numeric constant:

			l->arg3_type = CONSTANT;
			l->const_val = binary value of arg3

		if arg3 is a character constant:

			l->arg3_type = CHAR;
			l->const_val = 0;

		if arg3 is a "w5<o5>" pair:

			l->arg3_type = WIDTH;
			l->const_val = 0;
										*/






	  /* array of all legal register names  MUST BE SORTED!!! */

	  static char  *regnames[] = { "cr0", "cr1", "cr10", "cr11", "cr12","cr13",
					"cr14", "cr15", "cr16", "cr17", "cr18",
					"cr19", "cr2", "cr20", "cr3", "cr4", "cr5",
					"cr6", "cr7", "cr8", "cr9", "fcr0", "fcr1",
					"fcr2", "fcr3", "fcr4", "fcr5", "fcr6",
					"fcr62", "fcr63", "fcr7", "fcr8", "r0", "r1",
					"r10", "r11", "r12", "r13", "r14", "r15", "r16",
					"r17", "r18", "r19", "r2", "r20", "r21",
					"r22", "r23", "r24", "r25", "r26", "r27",
					"r28", "r29", "r3", "r30", "r31", "r4", "r5",
					"r6", "r7", "r8", "r9", "sp" };

#define NRNAMES 65	/* number of entries in above */


	  l->arg3_type = UNKNOWN;
	  l->const_val = 0;

	  if( search(l->arg3, regnames, NRNAMES) ) {
	    l->arg3_type = REGISTER;
	    /* fprintf(fpout, ";arg3 type is REGISTER\n"); */
	    return;
	  }


	  /* make sure we don't treat "w5<o5>" type third args as constants */

	  if( strlen(l->arg4) != 0 ) {
	    l->arg3_type = WIDTH;
	    /* fprintf(fpout, ";arg3 type is WIDTH\n"); */
	    return;
	  }


	  /* check for a pseudo-op which is legal as a third argument
	     (currently only "hi16(expr)" or "lo16(expr)")		*/

	  if( (strncmp(l->arg3, "hi16(", 5) == 0)    ||
	      (strncmp(l->arg3, "lo16(", 5) == 0) )  {
		l->arg3_type = PSEUDO;
		return;
	  }


	  /* numbers can start with 0x or 0X (hex), 0 (octal), or 1-9 (decimal) */

	  if( isdigit(l->arg3[0]) ) {
	    /* fprintf(fpout, ";arg3 type is CONSTANT\n"); */
	    l->arg3_type = CONSTANT;
	    l->const_val = strtol(l->arg3, (char **)NULL, 0);
	  }
	  else {  /* either a label or a character constant */
	    if( l->arg3[0] == '\'' )
	      l->arg3_type = CHAR;
	    else
	      l->arg3_type = LABEL;
	  }
	  return;
	}






	/*
		search


		find string "word" in array "table", whose length is "tabln"
		"table" MUST be sorted!!!

		return FALSE if not found, TRUE if found
	*/

	search(word, table, tabln)
	char *word, **table;
	int tabln;
	{
	   int  low, mid, high, cond;

	   low = 0;
	   high = tabln - 1;

	   while( low <= high ) {

		mid = (low + high) / 2;
		if( (cond = strcmp(word, table[mid])) < 0 )
		  high = mid - 1;
		else if( cond > 0 )
			low = mid + 1;
		else
		     return(TRUE);
	   }
	   return(FALSE);
	}





	/*
		END COMMON routines
	*/

	/*
		showstats:
	*/
	showstats()
	{
	/*
		What some folks won't do to keep their source program lines
		less than 80 character positions ...
	*/
		static char	m1[] = " instruction";
		static char	m2[] = "s";
		static char	m3[] = " fixed\n";
		static char 	f1[] = "%d %s %s%s%s";
		static char 	f2[] = "%d %s.%s %s%s%s";
		static char 	f3[] = "%d %s.%s.%s %s%s%s";

		register struct fixup *p;      
		p = mnemonics;
		while ( p->name ) {        
		   if ( p->cnt == 1 ) {
		      m2[0] = '\0';
		   }
		   else {
		      m2[0] = 's';
		   }
		   if ( p->sufx1[0] == '\0' ) {
		      fprintf(stderr, f1, p->cnt, p->name, m1, m2, m3);
		   }
		   else {
		      if ( p->sufx2[0] == '\0' ) {
			 fprintf(stderr, f2, p->cnt, p->name, p->sufx1, m1, m2, m3);
		      }
		      else {
			 fprintf(stderr,f3,p->cnt,p->name,p->sufx1,p->sufx2,m1,m2,m3);
		      }
		   }
		   p++;
		}
		return ( 0 );                 
}
